{
  "id": "42471188",
  "stage": "evaluate",
  "repo_addr": "https://github.com/darktable-org/rawspeed.git",
  "fix_commit": "7473d21494834f72f984b0e2a06346bd68fb6e1c",
  "project": "librawspeed",
  "report": "V0FSTklORzogTWVtb3J5U2FuaXRpemVyOiB1c2Utb2YtdW5pbml0aWFsaXplZC12YWx1ZQ0KICAgICMwIDB4NTBjODI3IGluIHJhd3NwZWVkOjpWQzVEZWNvbXByZXNzb3I6OnBhcnNlTGFyZ2VDb2RlYmxvY2socmF3c3BlZWQ6OkJ5dGVTdHJlYW0gY29uc3QmKSAvc3JjL2xpYnJhd3NwZWVkL3NyYy9saWJyYXdzcGVlZC9kZWNvbXByZXNzb3JzL1ZDNURlY29tcHJlc3Nvci5jcHA6NTY5OjE5DQogICAgIzEgMHg1MDkxYTggaW4gcmF3c3BlZWQ6OlZDNURlY29tcHJlc3Nvcjo6cGFyc2VWQzUoKSAvc3JjL2xpYnJhd3NwZWVkL3NyYy9saWJyYXdzcGVlZC9kZWNvbXByZXNzb3JzL1ZDNURlY29tcHJlc3Nvci5jcHA6NDY3OjkNCiAgICAjMiAweDUwNzQ0YyBpbiByYXdzcGVlZDo6VkM1RGVjb21wcmVzc29yOjpWQzVEZWNvbXByZXNzb3IocmF3c3BlZWQ6OkJ5dGVTdHJlYW0sIHJhd3NwZWVkOjpSYXdJbWFnZSBjb25zdCYpIC9zcmMvbGlicmF3c3BlZWQvc3JjL2xpYnJhd3NwZWVkL2RlY29tcHJlc3NvcnMvVkM1RGVjb21wcmVzc29yLmNwcDozMjY6Mw0KICAgICMzIDB4NGRjY2EzIGluIExMVk1GdXp6ZXJUZXN0T25lSW5wdXQgL3NyYy9saWJyYXdzcGVlZC9mdXp6L2xpYnJhd3NwZWVkL2RlY29tcHJlc3NvcnMvVkM1RGVjb21wcmVzc29yLmNwcDo1MDozMQ0KICAgICM0IDB4NTc5ODBiIGluIGZ1enplcjo6RnV6emVyOjpFeGVjdXRlQ2FsbGJhY2sodW5zaWduZWQgY2hhciBjb25zdCosIHVuc2lnbmVkIGxvbmcpIC9zcmMvbGliZnV6emVyL0Z1enplckxvb3AuY3BwOjU3MDoxNQ0KICAgICM1IDB4NTMxZDA2IGluIGZ1enplcjo6UnVuT25lVGVzdChmdXp6ZXI6OkZ1enplciosIGNoYXIgY29uc3QqLCB1bnNpZ25lZCBsb25nKSAvc3JjL2xpYmZ1enplci9GdXp6ZXJEcml2ZXIuY3BwOjI4MDo2DQogICAgIzYgMHg1NDJiMmEgaW4gZnV6emVyOjpGdXp6ZXJEcml2ZXIoaW50KiwgY2hhcioqKiwgaW50ICgqKSh1bnNpZ25lZCBjaGFyIGNvbnN0KiwgdW5zaWduZWQgbG9uZykpIC9zcmMvbGliZnV6emVyL0Z1enplckRyaXZlci5jcHA6NzEzOjkNCiAgICAjNyAweDUzMGUzMSBpbiBtYWluIC9zcmMvbGliZnV6emVyL0Z1enplck1haW4uY3BwOjIwOjEwDQogICAgIzggMHg3ZmZmZjZlZTU4MmYgaW4gX19saWJjX3N0YXJ0X21haW4gKC9saWIveDg2XzY0LWxpbnV4LWdudS9saWJjLnNvLjYrMHgyMDgyZikNCiAgICAjOSAweDQ1OGI5OCBpbiBfc3RhcnQgKC9vdXQvVkM1RGVjb21wcmVzc29yRnV6emVyKzB4NDU4Yjk4KQ0KDQpERURVUF9UT0tFTjogcmF3c3BlZWQ6OlZDNURlY29tcHJlc3Nvcjo6cGFyc2VMYXJnZUNvZGVibG9jayhyYXdzcGVlZDo6Qnl0ZVN0cmVhbSBjb25zdCYpLS1yYXdzcGVlZDo6VkM1RGVjb21wcmVzc29yOjpwYXJzZVZDNSgpLS1yYXdzcGVlZDo6VkM1RGVjb21wcmVzc29yOjpWQzVEZWNvbXByZXNzb3IocmF3c3BlZWQ6OkJ5dGVTdHJlYW0sIHJhd3NwZWVkOjpSYXdJbWFnZSBjb25zdCYpDQogIFVuaW5pdGlhbGl6ZWQgdmFsdWUgd2FzIGNyZWF0ZWQgYnkgYW4gYWxsb2NhdGlvbiBvZiAndicgaW4gdGhlIHN0YWNrIGZyYW1lIG9mIGZ1bmN0aW9uICdMTFZNRnV6emVyVGVzdE9uZUlucHV0Jw0KICAgICMwIDB4NGRjMGMwIGluIExMVk1GdXp6ZXJUZXN0T25lSW5wdXQgL3NyYy9saWJyYXdzcGVlZC9mdXp6L2xpYnJhd3NwZWVkL2RlY29tcHJlc3NvcnMvVkM1RGVjb21wcmVzc29yLmNwcDozNA0KDQpERURVUF9UT0tFTjogTExWTUZ1enplclRlc3RPbmVJbnB1dA0KU1VNTUFSWTogTWVtb3J5U2FuaXRpemVyOiB1c2Utb2YtdW5pbml0aWFsaXplZC12YWx1ZSAvc3JjL2xpYnJhd3NwZWVkL3NyYy9saWJyYXdzcGVlZC9kZWNvbXByZXNzb3JzL1ZDNURlY29tcHJlc3Nvci5jcHA6NTY5OjE5IGluIHJhd3NwZWVkOjpWQzVEZWNvbXByZXNzb3I6OnBhcnNlTGFyZ2VDb2RlYmxvY2socmF3c3BlZWQ6OkJ5dGVTdHJlYW0gY29uc3QmKQ0KVW5pcXVlIGhlYXAgb3JpZ2luczogNDANClN0YWNrIGRlcG90IGFsbG9jYXRlZCBieXRlczogMjQ5Ng0KVW5pcXVlIG9yaWdpbiBoaXN0b3JpZXM6IDYNCkhpc3RvcnkgZGVwb3QgYWxsb2NhdGVkIGJ5dGVzOiAxNDQNCkV4aXRpbmc=",
  "requested_content": {
    "/src/librawspeed/src/librawspeed/decompressors/VC5Decompressor.cpp": {
      "539": "line  539 : }",
      "540": "line  540 : ",
      "541": "line  541 : void VC5Decompressor::parseLargeCodeblock(const ByteStream& bs) {",
      "542": "line  542 :   static const auto subband_wavelet_index = []() {",
      "543": "line  543 :     std::array<int, numSubbands> wavelets;",
      "544": "line  544 :     int wavelet = 0;",
      "545": "line  545 :     for (auto i = wavelets.size() - 1; i > 0;) {",
      "546": "line  546 :       for (auto t = 0; t < numWaveletLevels; t++) {",
      "547": "line  547 :         wavelets[i] = wavelet;",
      "548": "line  548 :         i--;",
      "549": "line  549 :       }",
      "550": "line  550 :       if (i > 0)",
      "551": "line  551 :         wavelet++;",
      "552": "line  552 :     }",
      "553": "line  553 :     wavelets.front() = wavelet;",
      "554": "line  554 :     return wavelets;",
      "555": "line  555 :   }();",
      "556": "line  556 :   static const auto subband_band_index = []() {",
      "557": "line  557 :     std::array<int, numSubbands> bands;",
      "558": "line  558 :     bands.front() = 0;",
      "559": "line  559 :     for (auto i = 1U; i < bands.size();) {",
      "560": "line  560 :       for (int t = 1; t <= numWaveletLevels;) {",
      "561": "line  561 :         bands[i] = t;",
      "562": "line  562 :         t++;",
      "563": "line  563 :         i++;",
      "564": "line  564 :       }",
      "565": "line  565 :     }",
      "566": "line  566 :     return bands;",
      "567": "line  567 :   }();",
      "568": "line  568 : ",
      "569": "line  569 :   const int idx = subband_wavelet_index[mVC5.iSubband];",
      "570": "line  570 :   const int band = subband_band_index[mVC5.iSubband];",
      "571": "line  571 : ",
      "572": "line  572 :   auto& wavelets = channels[mVC5.iChannel].wavelets;",
      "573": "line  573 : ",
      "574": "line  574 :   Wavelet& wavelet = wavelets[idx];",
      "575": "line  575 :   if (wavelet.isBandValid(band)) {",
      "576": "line  576 :     ThrowRDE(\"Band %u for wavelet %u on channel %u was already seen\", band, idx,",
      "577": "line  577 :              mVC5.iChannel);",
      "578": "line  578 :   }",
      "579": "line  579 : ",
      "580": "line  580 :   std::unique_ptr<Wavelet::AbstractBand>& dstBand = wavelet.bands[band];",
      "581": "line  581 :   if (mVC5.iSubband == 0) {",
      "582": "line  582 :     assert(band == 0);",
      "583": "line  583 :     // low-pass band, only one, for the smallest wavelet, per channel per image",
      "584": "line  584 :     dstBand = std::make_unique<Wavelet::LowPassBand>(bs, mVC5.lowpassPrecision);",
      "585": "line  585 :   } else {",
      "586": "line  586 :     dstBand = std::make_unique<Wavelet::HighPassBand>(bs, mVC5.quantization);",
      "587": "line  587 :   }",
      "588": "line  588 :   wavelet.setBandValid(band);",
      "589": "line  589 : ",
      "590": "line  590 :   // If this wavelet is fully specified, mark the low-pass band of the",
      "591": "line  591 :   // next lower wavelet as specified.",
      "592": "line  592 :   if (idx > 0 && wavelet.allBandsValid()) {",
      "593": "line  593 :     Wavelet& nextWavelet = wavelets[idx - 1];",
      "594": "line  594 :     assert(!nextWavelet.isBandValid(0));",
      "595": "line  595 :     nextWavelet.bands[0] = std::make_unique<Wavelet::ReconstructableBand>();",
      "596": "line  596 :     nextWavelet.setBandValid(0);",
      "597": "line  597 :   }",
      "598": "line  598 : }",
      "785": "line  785 : <End of File>",
      "296": "line  296 :   if (mRaw->dim.x > std::numeric_limits<decltype(Channel::width)>::max())",
      "297": "line  297 :     ThrowRDE(\"Width %u is too large\", mRaw->dim.x);",
      "298": "line  298 : ",
      "299": "line  299 :   if (mRaw->dim.y > std::numeric_limits<decltype(Channel::height)>::max())",
      "300": "line  300 :     ThrowRDE(\"Height %u is too large\", mRaw->dim.y);",
      "301": "line  301 : ",
      "302": "line  302 :   // Initialize wavelet sizes.",
      "303": "line  303 :   for (Channel& channel : channels) {",
      "304": "line  304 :     channel.width = mRaw->dim.x / mVC5.patternWidth;",
      "305": "line  305 :     channel.height = mRaw->dim.y / mVC5.patternHeight;",
      "306": "line  306 : ",
      "307": "line  307 :     uint16_t waveletWidth = channel.width;",
      "308": "line  308 :     uint16_t waveletHeight = channel.height;",
      "309": "line  309 :     for (Wavelet& wavelet : channel.wavelets) {",
      "310": "line  310 :       // Pad dimensions as necessary and divide them by two for the next wavelet",
      "311": "line  311 :       for (auto* dimension : {&waveletWidth, &waveletHeight})",
      "312": "line  312 :         *dimension = roundUpDivision(*dimension, 2);",
      "313": "line  313 :       wavelet.width = waveletWidth;",
      "314": "line  314 :       wavelet.height = waveletHeight;",
      "315": "line  315 :     }",
      "316": "line  316 :   }",
      "317": "line  317 : ",
      "318": "line  318 :   if (img->whitePoint <= 0 || img->whitePoint > int(((1U << 16U) - 1U)))",
      "319": "line  319 :     ThrowRDE(\"Bad white level %i\", img->whitePoint);",
      "320": "line  320 : ",
      "321": "line  321 :   outputBits = 0;",
      "322": "line  322 :   for (int wp = img->whitePoint; wp != 0; wp >>= 1)",
      "323": "line  323 :     ++outputBits;",
      "324": "line  324 :   assert(outputBits <= 16);",
      "325": "line  325 : ",
      "326": "line  326 :   parseVC5();",
      "327": "line  327 : }",
      "328": "line  328 : ",
      "329": "line  329 : void VC5Decompressor::initVC5LogTable() {",
      "330": "line  330 :   mVC5LogTable = decltype(mVC5LogTable)(",
      "331": "line  331 :       [outputBits = outputBits](unsigned i, unsigned tableSize) {",
      "332": "line  332 :         // The vanilla \"inverse log\" curve for decoding.",
      "333": "line  333 :         auto normalizedCurve = [](auto normalizedI) {",
      "334": "line  334 :           return (std::pow(113.0, normalizedI) - 1) / 112.0;",
      "335": "line  335 :         };",
      "336": "line  336 : ",
      "337": "line  337 :         auto normalizeI = [tableSize](auto x) { return x / (tableSize - 1.0); };",
      "338": "line  338 :         auto denormalizeY = [maxVal = std::numeric_limits<ushort16>::max()](",
      "339": "line  339 :                                 auto y) { return maxVal * y; };",
      "340": "line  340 :         // Adjust for output whitelevel bitdepth.",
      "341": "line  341 :         auto rescaleY = [outputBits](auto y) {",
      "342": "line  342 :           auto scale = 16 - outputBits;",
      "343": "line  343 :           return y >> scale;",
      "344": "line  344 :         };",
      "345": "line  345 : ",
      "346": "line  346 :         const auto naiveY = denormalizeY(normalizedCurve(normalizeI(i)));",
      "347": "line  347 :         const auto intY = static_cast<unsigned int>(naiveY);",
      "348": "line  348 :         const auto rescaledY = rescaleY(intY);",
      "349": "line  349 :         return rescaledY;",
      "350": "line  350 :       });",
      "351": "line  351 : }",
      "352": "line  352 : ",
      "353": "line  353 : const SimpleLUT<int16_t, 16> VC5Decompressor::mVC5DecompandingTable = []() {",
      "354": "line  354 :   auto dequantize = [](int16_t val) -> int16_t {",
      "355": "line  355 :     double c = val;",
      "437": "line  437 :       mVC5.iSubband = val;",
      "438": "line  438 :       break;",
      "439": "line  439 :     case VC5Tag::Quantization:",
      "440": "line  440 :       mVC5.quantization = static_cast<short16>(val);",
      "441": "line  441 :       break;",
      "442": "line  442 :     case VC5Tag::ComponentsPerSample:",
      "443": "line  443 :       if (val != mVC5.cps)",
      "444": "line  444 :         ThrowRDE(\"Bad compnent per sample count %u, not %u\", val, mVC5.cps);",
      "445": "line  445 :       break;",
      "446": "line  446 :     case VC5Tag::PrescaleShift:",
      "447": "line  447 :       // FIXME: something is wrong. We get this before VC5Tag::ChannelNumber.",
      "448": "line  448 :       // Defaulting to 'mVC5.iChannel=0' seems to work *for existing samples*.",
      "449": "line  449 :       for (int iWavelet = 0; iWavelet < numWaveletLevels; ++iWavelet) {",
      "450": "line  450 :         auto& channel = channels[mVC5.iChannel];",
      "451": "line  451 :         auto& wavelet = channel.wavelets[iWavelet];",
      "452": "line  452 :         wavelet.prescale = (val >> (14 - 2 * iWavelet)) & 0x03;",
      "453": "line  453 :       }",
      "454": "line  454 :       break;",
      "455": "line  455 :     default: { // A chunk.",
      "456": "line  456 :       unsigned int chunkSize = 0;",
      "457": "line  457 :       if (matches(tag, VC5Tag::LARGE_CHUNK)) {",
      "458": "line  458 :         chunkSize = static_cast<unsigned int>(",
      "459": "line  459 :             ((static_cast<std::underlying_type<VC5Tag>::type>(tag) & 0xff)",
      "460": "line  460 :              << 16) |",
      "461": "line  461 :             (val & 0xffff));",
      "462": "line  462 :       } else if (matches(tag, VC5Tag::SMALL_CHUNK)) {",
      "463": "line  463 :         chunkSize = (val & 0xffff);",
      "464": "line  464 :       }",
      "465": "line  465 : ",
      "466": "line  466 :       if (is(tag, VC5Tag::LargeCodeblock)) {",
      "467": "line  467 :         parseLargeCodeblock(mBs.getStream(chunkSize, 4));",
      "468": "line  468 :         break;",
      "469": "line  469 :       }",
      "470": "line  470 : ",
      "471": "line  471 :       // And finally, we got here if we didn't handle this tag/maybe-chunk.",
      "472": "line  472 : ",
      "473": "line  473 :       // Magic, all the other 'large' chunks are actually optional,",
      "474": "line  474 :       // and don't specify any chunk bytes-to-be-skipped.",
      "475": "line  475 :       if (matches(tag, VC5Tag::LARGE_CHUNK)) {",
      "476": "line  476 :         optional = true;",
      "477": "line  477 :         chunkSize = 0;",
      "478": "line  478 :       }",
      "479": "line  479 : ",
      "480": "line  480 :       if (!optional) {",
      "481": "line  481 :         ThrowRDE(\"Unknown (unhandled) non-optional Tag 0x%04hx\",",
      "482": "line  482 :                  static_cast<std::underlying_type<VC5Tag>::type>(tag));",
      "483": "line  483 :       }",
      "484": "line  484 : ",
      "485": "line  485 :       if (chunkSize)",
      "486": "line  486 :         mBs.skipBytes(chunkSize, 4);",
      "487": "line  487 : ",
      "488": "line  488 :       break;",
      "489": "line  489 :     }",
      "490": "line  490 :     }",
      "491": "line  491 : ",
      "492": "line  492 :     done = true;",
      "493": "line  493 :     for (int iChannel = 0; iChannel < numChannels && done; ++iChannel) {",
      "494": "line  494 :       Wavelet& wavelet = channels[iChannel].wavelets[0];",
      "495": "line  495 :       if (!wavelet.allBandsValid())",
      "496": "line  496 :         done = false;"
    },
    "/src/librawspeed/fuzz/librawspeed/decompressors/VC5Decompressor.cpp": {
      "1": "line    1 : /*",
      "2": "line    2 :     RawSpeed - RAW file decoder.",
      "3": "line    3 : ",
      "4": "line    4 :     Copyright (C) 2018 Roman Lebedev",
      "5": "line    5 : ",
      "6": "line    6 :     This library is free software; you can redistribute it and/or",
      "7": "line    7 :     modify it under the terms of the GNU Lesser General Public",
      "8": "line    8 :     License as published by the Free Software Foundation; either",
      "9": "line    9 :     version 2 of the License, or (at your option) any later version.",
      "10": "line   10 : ",
      "11": "line   11 :     This library is distributed in the hope that it will be useful,",
      "12": "line   12 :     but WITHOUT ANY WARRANTY; without even the implied warranty of",
      "13": "line   13 :     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU",
      "14": "line   14 :     Lesser General Public License for more details.",
      "15": "line   15 : ",
      "16": "line   16 :     You should have received a copy of the GNU Lesser General Public",
      "17": "line   17 :     License along with this library; if not, write to the Free Software",
      "18": "line   18 :     Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA",
      "19": "line   19 : */",
      "20": "line   20 : ",
      "21": "line   21 : #include \"decompressors/VC5Decompressor.h\" // for VC5Decompressor",
      "22": "line   22 : #include \"common/RawImage.h\"               // for RawImage",
      "23": "line   23 : #include \"common/RawspeedException.h\"      // for RawspeedException",
      "24": "line   24 : #include \"fuzz/Common.h\"                   // for CreateRawImage",
      "25": "line   25 : #include \"io/Buffer.h\"                     // for Buffer, DataBuffer",
      "26": "line   26 : #include \"io/ByteStream.h\"                 // for ByteStream",
      "27": "line   27 : #include \"io/Endianness.h\"                 // for Endianness, Endianne...",
      "28": "line   28 : #include <cassert>                         // for assert",
      "29": "line   29 : #include <cstdint>                         // for uint8_t",
      "30": "line   30 : #include <cstdio>                          // for size_t",
      "31": "line   31 : ",
      "32": "line   32 : extern \"C\" int LLVMFuzzerTestOneInput(const uint8_t* Data, size_t Size);",
      "33": "line   33 : ",
      "34": "line   34 : extern \"C\" int LLVMFuzzerTestOneInput(const uint8_t* Data, size_t Size) {",
      "35": "line   35 :   assert(Data);",
      "36": "line   36 : ",
      "37": "line   37 :   try {",
      "38": "line   38 :     const rawspeed::Buffer b(Data, Size);",
      "39": "line   39 :     const rawspeed::DataBuffer db(b, rawspeed::Endianness::little);",
      "40": "line   40 :     rawspeed::ByteStream bs(db);",
      "41": "line   41 : ",
      "42": "line   42 :     rawspeed::RawImage mRaw(CreateRawImage(&bs));",
      "43": "line   43 :     mRaw->whitePoint = bs.getI32();",
      "44": "line   44 : ",
      "45": "line   45 :     const auto offsetX = bs.getU32();",
      "46": "line   46 :     const auto offsetY = bs.getU32();",
      "47": "line   47 :     const auto width = bs.getU32();",
      "48": "line   48 :     const auto height = bs.getU32();",
      "49": "line   49 : ",
      "50": "line   50 :     rawspeed::VC5Decompressor v(bs, mRaw);",
      "51": "line   51 :     mRaw->createData();",
      "52": "line   52 :     v.decode(offsetX, offsetY, width, height);",
      "53": "line   53 : ",
      "54": "line   54 :     // VC5Decompressor is special",
      "55": "line   55 :     // It is expected to be the only DNG tile, and to fill the entire image.",
      "56": "line   56 :     mRaw->checkMemIsInitialized();",
      "57": "line   57 :   } catch (rawspeed::RawspeedException&) {",
      "58": "line   58 :     // Exceptions are good, crashes are bad.",
      "59": "line   59 :   }",
      "64": "line   64 : <End of File>"
    },
    "/src/librawspeed/src/librawspeed/decompressors/VC5Decompressor.h": {
      "1": "line    1 : /*",
      "2": "line    2 :     RawSpeed - RAW file decoder.",
      "3": "line    3 : ",
      "4": "line    4 :     Copyright (C) 2018 Stefan Löffler",
      "5": "line    5 :     Copyright (C) 2018 Roman Lebedev",
      "6": "line    6 : ",
      "7": "line    7 :     This library is free software; you can redistribute it and/or",
      "8": "line    8 :     modify it under the terms of the GNU Lesser General Public",
      "9": "line    9 :     License as published by the Free Software Foundation; either",
      "10": "line   10 :     version 2 of the License, or (at your option) any later version.",
      "11": "line   11 : ",
      "12": "line   12 :     This library is distributed in the hope that it will be useful,",
      "13": "line   13 :     but WITHOUT ANY WARRANTY; without even the implied warranty of",
      "14": "line   14 :     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU",
      "15": "line   15 :     Lesser General Public License for more details.",
      "16": "line   16 : ",
      "17": "line   17 :     You should have received a copy of the GNU Lesser General Public",
      "18": "line   18 :     License along with this library; if not, write to the Free Software",
      "19": "line   19 :     Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA",
      "20": "line   20 : */",
      "21": "line   21 : ",
      "22": "line   22 : #pragma once",
      "23": "line   23 : ",
      "24": "line   24 : #include \"common/Array2DRef.h\" // for Array2DRef",
      "25": "line   25 : #include \"common/Common.h\"     // for uint32",
      "26": "line   26 : #include \"common/RawImage.h\"   // for RawImageData",
      "27": "line   27 : #include \"common/SimpleLUT.h\"  // for SimpleLUT",
      "28": "line   28 : #include \"decompressors/AbstractDecompressor.h\" // for AbstractDecompressor",
      "29": "line   29 : #include \"io/BitPumpMSB.h\" // for BitPumpMSB",
      "30": "line   30 : #include \"io/ByteStream.h\" // for ByteStream",
      "31": "line   31 : #include <functional>      // for reference_wrapper",
      "32": "line   32 : #include <type_traits>     // for underlying_type",
      "33": "line   33 : ",
      "34": "line   34 : namespace rawspeed {",
      "35": "line   35 : ",
      "36": "line   36 : const int MAX_NUM_PRESCALE = 8;",
      "37": "line   37 : ",
      "38": "line   38 : class ByteStream;",
      "39": "line   39 : class RawImage;",
      "40": "line   40 : ",
      "41": "line   41 : // Decompresses VC-5 as used by GoPro",
      "42": "line   42 : ",
      "43": "line   43 : enum class VC5Tag : int16_t {",
      "44": "line   44 :   NoTag = 0x0, // synthetic, not an actual tag",
      "45": "line   45 : ",
      "46": "line   46 :   ChannelCount = 0x000c,",
      "47": "line   47 :   ImageWidth = 0x0014,",
      "48": "line   48 :   ImageHeight = 0x0015,",
      "49": "line   49 :   LowpassPrecision = 0x0023,",
      "50": "line   50 :   SubbandCount = 0x000E,",
      "51": "line   51 :   SubbandNumber = 0x0030,",
      "52": "line   52 :   Quantization = 0x0035,",
      "53": "line   53 :   ChannelNumber = 0x003e,",
      "54": "line   54 :   ImageFormat = 0x0054,",
      "55": "line   55 :   MaxBitsPerComponent = 0x0066,",
      "56": "line   56 :   PatternWidth = 0x006a,",
      "57": "line   57 :   PatternHeight = 0x006b,",
      "58": "line   58 :   ComponentsPerSample = 0x006c,",
      "59": "line   59 :   PrescaleShift = 0x006d,",
      "60": "line   60 : ",
      "222": "line  222 : <End of File>"
    }
  },
  "note": [
    "Reason for requesting line 569 of /src/librawspeed/src/librawspeed/decompressors/VC5Decompressor.cpp: To understand what is being accessed uninitialized in parseLargeCodeblock.",
    "Reason for requesting line 30 of /src/librawspeed/fuzz/librawspeed/decompressors/VC5Decompressor.cpp: To understand how 'v' is allocated and used to initialize the VC5Decompressor, which might lead to an uninitialized 'mVC5.iSubband'.",
    "Reason for requesting line 326 of /src/librawspeed/src/librawspeed/decompressors/VC5Decompressor.cpp: To understand how the `mVC5` member, specifically `mVC5.iSubband`, is initialized within the VC5Decompressor constructor.",
    "Reason for requesting line 31 of /src/librawspeed/src/librawspeed/decompressors/VC5Decompressor.h: To understand the definition of `mVC5` and how its members, specifically `iSubband`, are initialized within the `VC5Decompressor` class, and also the `parseVC5` method to see where `iSubband` is populated.",
    "Reason for requesting line 467 of /src/librawspeed/src/librawspeed/decompressors/VC5Decompressor.cpp: To understand how mVC5.iSubband is populated, specifically in the parseVC5 method."
  ],
  "valid_patches": [
    {
      "file": "/src/librawspeed/src/librawspeed/decompressors/VC5Decompressor.cpp",
      "diff": [
        {
          "line_number": 325,
          "content": [
            "  assert(outputBits <= 16);",
            "  mVC5.iSubband = 0; // Initialize iSubband to a safe default"
          ]
        }
      ]
    }
  ],
  "retry_count": 8,
  "history": [
    {
      "reason": "To understand what is being accessed uninitialized in parseLargeCodeblock.",
      "line": 569,
      "file": "/src/librawspeed/src/librawspeed/decompressors/VC5Decompressor.cpp"
    },
    {
      "reason": "To understand how 'v' is allocated and used to initialize the VC5Decompressor, which might lead to an uninitialized 'mVC5.iSubband'.",
      "line": 30,
      "file": "/src/librawspeed/fuzz/librawspeed/decompressors/VC5Decompressor.cpp"
    },
    {
      "reason": "To understand how the `mVC5` member, specifically `mVC5.iSubband`, is initialized within the VC5Decompressor constructor.",
      "line": 326,
      "file": "/src/librawspeed/src/librawspeed/decompressors/VC5Decompressor.cpp"
    },
    {
      "reason": "To understand the definition of `mVC5` and how its members, specifically `iSubband`, are initialized within the `VC5Decompressor` class, and also the `parseVC5` method to see where `iSubband` is populated.",
      "line": 31,
      "file": "/src/librawspeed/src/librawspeed/decompressors/VC5Decompressor.h"
    },
    {
      "reason": "To understand how mVC5.iSubband is populated, specifically in the parseVC5 method.",
      "line": 467,
      "file": "/src/librawspeed/src/librawspeed/decompressors/VC5Decompressor.cpp"
    },
    {
      "reason": "To confirm how `mVC5` and its members, specifically `iSubband`, are declared and initialized within the `VC5Decompressor` class.",
      "line": 60,
      "file": "/src/librawspeed/src/librawspeed/decompressors/VC5Decompressor.h"
    },
    {
      "reason": "The `mVC5.iSubband` member of `VC5Decompressor` is not initialized by default and may be used before being assigned a value from the input stream. This leads to a use-of-uninitialized-value error when `parseLargeCodeblock` is called if the `VC5Tag::SubbandNumber` is not present in the input. The fix is to initialize `mVC5.iSubband` to a safe default value (0) in the constructor initializer list.",
      "patches": [
        {
          "file": "/src/librawspeed/src/librawspeed/decompressors/VC5Decompressor.cpp",
          "diff": [
            {
              "line_number": 325,
              "content": [
                "  assert(outputBits <= 16);",
                "",
                "  // Initialize all values that might be read from the bytestream later",
                "  // to safe defaults. This avoids use-of-uninitialized-value if an",
                "  // optional tag is missing from a fuzzer input.",
                "  mVC5.iSubband = 0;",
                "",
                "  parseVC5();"
              ]
            }
          ]
        }
      ]
    },
    {
      "reason": "The member `mVC5.iSubband` is used in `parseLargeCodeblock` at line 569 without guaranteed initialization. The fuzzer input may not always provide a `VC5Tag::SubbandNumber` before a `VC5Tag::LargeCodeblock`, leading to an uninitialized read. Initializing `mVC5.iSubband` to a default safe value (e.g., 0) in the `VC5Decompressor` constructor ensures it always has a defined state.",
      "patches": [
        {
          "file": "/src/librawspeed/src/librawspeed/decompressors/VC5Decompressor.cpp",
          "diff": [
            {
              "line_number": 325,
              "content": [
                "  assert(outputBits <= 16);",
                "  mVC5.iSubband = 0; // Initialize iSubband to a safe default"
              ]
            }
          ]
        }
      ]
    }
  ]
}