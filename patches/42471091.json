{
  "id": "42471091",
  "stage": "evaluate",
  "repo_addr": "https://github.com/harfbuzz/harfbuzz.git",
  "fix_commit": "0f85edb7781f4d5ec2de676979be75a0f6559d80",
  "project": "harfbuzz",
  "report": "V0FSTklORzogTWVtb3J5U2FuaXRpemVyOiB1c2Utb2YtdW5pbml0aWFsaXplZC12YWx1ZQ0KICAgICMwIDB4NWIzOGY1IGluIGhiX3Nhbml0aXplX2NvbnRleHRfdDo6Y2hlY2tfcmFuZ2Uodm9pZCBjb25zdCosIHVuc2lnbmVkIGludCkgY29uc3QgL3NyYy9oYXJmYnV6ei9zcmMvLi9oYi1tYWNoaW5lcnkuaGg6Mjg2OjI1DQogICAgIzEgMHg1Y2RmZDMgaW4gT1Q6OkludFR5cGU8dW5zaWduZWQgc2hvcnQsIDJ1Pjo6c2FuaXRpemUoaGJfc2FuaXRpemVfY29udGV4dF90KikgY29uc3QgL3NyYy9oYXJmYnV6ei9zcmMvLi9oYi1vcGVuLXR5cGUuaGg6NzY6NQ0KICAgICMyIDB4NmNmNTljIGluIEFBVDo6TGlnYXR1cmVTdWJ0YWJsZTo6ZHJpdmVyX2NvbnRleHRfdDo6dHJhbnNpdGlvbihBQVQ6OlN0YXRlVGFibGVEcml2ZXI8QUFUOjpMaWdhdHVyZVN1YnRhYmxlOjpFbnRyeURhdGE-KiwgQUFUOjpFbnRyeTxBQVQ6OkxpZ2F0dXJlU3VidGFibGU6OkVudHJ5RGF0YT4gY29uc3QqKSAvc3JjL2hhcmZidXp6L3NyYy8uL2hiLWFhdC1sYXlvdXQtbW9yeC10YWJsZS5oaDo0MTI6OA0KICAgICMzIDB4NmNkYzRkIGluIHZvaWQgQUFUOjpTdGF0ZVRhYmxlRHJpdmVyPEFBVDo6TGlnYXR1cmVTdWJ0YWJsZTo6RW50cnlEYXRhPjo6ZHJpdmU8QUFUOjpMaWdhdHVyZVN1YnRhYmxlOjpkcml2ZXJfY29udGV4dF90PihBQVQ6OkxpZ2F0dXJlU3VidGFibGU6OmRyaXZlcl9jb250ZXh0X3QqKSAvc3JjL2hhcmZidXp6L3NyYy8uL2hiLWFhdC1sYXlvdXQtY29tbW9uLmhoOjU4NToxMQ0KICAgICM0IDB4NmNjZDc5IGluIEFBVDo6TGlnYXR1cmVTdWJ0YWJsZTo6YXBwbHkoQUFUOjpoYl9hYXRfYXBwbHlfY29udGV4dF90KikgY29uc3QgL3NyYy9oYXJmYnV6ei9zcmMvLi9oYi1hYXQtbGF5b3V0LW1vcngtdGFibGUuaGg6NDYwOjEyDQogICAgIzUgMHg2YzRjODUgaW4gQUFUOjpoYl9hYXRfYXBwbHlfY29udGV4dF90OjpyZXR1cm5fdCBBQVQ6OkNoYWluU3VidGFibGU6OmRpc3BhdGNoPEFBVDo6aGJfYWF0X2FwcGx5X2NvbnRleHRfdD4oQUFUOjpoYl9hYXRfYXBwbHlfY29udGV4dF90KikgY29uc3QgL3NyYy9oYXJmYnV6ei9zcmMvLi9oYi1hYXQtbGF5b3V0LW1vcngtdGFibGUuaGg6NzgyOjIxDQogICAgIzYgMHg2YzQzYmQgaW4gQUFUOjpDaGFpbjo6YXBwbHkoQUFUOjpoYl9hYXRfYXBwbHlfY29udGV4dF90KikgY29uc3QgL3NyYy9oYXJmYnV6ei9zcmMvLi9oYi1hYXQtbGF5b3V0LW1vcngtdGFibGUuaGg6ODg3OjE3DQogICAgIzcgMHg2YjY0NjAgaW4gQUFUOjptb3J4OjphcHBseShBQVQ6OmhiX2FhdF9hcHBseV9jb250ZXh0X3QqKSBjb25zdCAvc3JjL2hhcmZidXp6L3NyYy8uL2hiLWFhdC1sYXlvdXQtbW9yeC10YWJsZS5oaDo5NjA6MTQNCiAgICAjOCAweDZiNWVmZCBpbiBoYl9hYXRfbGF5b3V0X3N1YnN0aXR1dGUoaGJfZm9udF90KiwgaGJfYnVmZmVyX3QqKSAvc3JjL2hhcmZidXp6L3NyYy9oYi1hYXQtbGF5b3V0LmNjOjcxOjgNCiAgICAjOSAweDYyY2I0ZCBpbiBoYl9vdF9zaGFwZV9pbnRlcm5hbChoYl9vdF9zaGFwZV9jb250ZXh0X3QqKSAvc3JjL2hhcmZidXp6L3NyYy9oYi1vdC1zaGFwZS5jYzo5MTc6Mw0KICAgICMxMCAweDYyYzNlNSBpbiBfaGJfb3Rfc2hhcGUgL3NyYy9oYXJmYnV6ei9zcmMvaGItb3Qtc2hhcGUuY2M6OTQ1OjMNCiAgICAjMTEgMHg1ZjI2NmYgaW4gaGJfc2hhcGVfcGxhbl9leGVjdXRlIC9zcmMvaGFyZmJ1enovc3JjLy4vaGItc2hhcGVyLWxpc3QuaGg6NDM6MQ0KICAgICMxMiAweDVlZjI2OCBpbiBoYl9zaGFwZV9mdWxsIC9zcmMvaGFyZmJ1enovc3JjL2hiLXNoYXBlLmNjOjE0MToxOQ0KICAgICMxMyAweDRhMjZjNCBpbiBMTFZNRnV6emVyVGVzdE9uZUlucHV0IC9zcmMvaGFyZmJ1enovLi90ZXN0L2Z1enppbmcvaGItc2hhcGUtZnV6emVyLmNjOjIwOjUNCiAgICAjMTQgMHg0ZWFkYWIgaW4gZnV6emVyOjpGdXp6ZXI6OkV4ZWN1dGVDYWxsYmFjayh1bnNpZ25lZCBjaGFyIGNvbnN0KiwgdW5zaWduZWQgbG9uZykgL3NyYy9saWJmdXp6ZXIvRnV6emVyTG9vcC5jcHA6NTcwOjE1DQogICAgIzE1IDB4NGEzYWY2IGluIGZ1enplcjo6UnVuT25lVGVzdChmdXp6ZXI6OkZ1enplciosIGNoYXIgY29uc3QqLCB1bnNpZ25lZCBsb25nKSAvc3JjL2xpYmZ1enplci9GdXp6ZXJEcml2ZXIuY3BwOjI4MDo2DQogICAgIzE2IDB4NGI0OTFhIGluIGZ1enplcjo6RnV6emVyRHJpdmVyKGludCosIGNoYXIqKiosIGludCAoKikodW5zaWduZWQgY2hhciBjb25zdCosIHVuc2lnbmVkIGxvbmcpKSAvc3JjL2xpYmZ1enplci9GdXp6ZXJEcml2ZXIuY3BwOjcxMzo5DQogICAgIzE3IDB4NGEyYzIxIGluIG1haW4gL3NyYy9saWJmdXp6ZXIvRnV6emVyTWFpbi5jcHA6MjA6MTANCiAgICAjMTggMHg3ZmZmZjZlZTU4MmYgaW4gX19saWJjX3N0YXJ0X21haW4gKC9saWIveDg2XzY0LWxpbnV4LWdudS9saWJjLnNvLjYrMHgyMDgyZikNCiAgICAjMTkgMHg0MWVmNzggaW4gX3N0YXJ0ICgvb3V0L2hiLXNoYXBlLWZ1enplcisweDQxZWY3OCkNCg0KREVEVVBfVE9LRU46IGhiX3Nhbml0aXplX2NvbnRleHRfdDo6Y2hlY2tfcmFuZ2Uodm9pZCBjb25zdCosIHVuc2lnbmVkIGludCkgY29uc3QtLU9UOjpJbnRUeXBlPHVuc2lnbmVkIHNob3J0LCAydT46OnNhbml0aXplKGhiX3Nhbml0aXplX2NvbnRleHRfdCopIGNvbnN0LS1BQVQ6OkxpZ2F0dXJlU3VidGFibGU6OmRyaXZlcl9jb250ZXh0X3Q6OnRyYW5zaXRpb24oQUFUOjpTdGF0ZVRhYmxlRHJpdmVyPEFBVDo6TGlnYXR1cmVTdWJ0YWJsZTo6RW50cnlEYXRhPiosIEFBVDo6RW50cnk8QUFUOjpMaWdhdHVyZVN1YnRhYmxlOjpFbnRyeURhdGE-IGNvbnN0KikNCiAgVW5pbml0aWFsaXplZCB2YWx1ZSB3YXMgY3JlYXRlZCBieSBhIGhlYXAgYWxsb2NhdGlvbg0KICAgICMwIDB4NDVlZTc1IGluIHJlYWxsb2MgL3NyYy9sbHZtL3Byb2plY3RzL2NvbXBpbGVyLXJ0L2xpYi9tc2FuL21zYW5faW50ZXJjZXB0b3JzLmNjOjg5Mg0KICAgICMxIDB4NTkwZjAwIGluIGhiX2J1ZmZlcl90OjplbmxhcmdlKHVuc2lnbmVkIGludCkgL3NyYy9oYXJmYnV6ei9zcmMvaGItYnVmZmVyLmNjOjEzODozNA0KICAgICMyIDB4NTkxOGZjIGluIGhiX2J1ZmZlcl90OjplbnN1cmUodW5zaWduZWQgaW50KSAvc3JjL2hhcmZidXp6L3NyYy8uL2hiLWJ1ZmZlci5oaDozMTc6NTYNCiAgICAjMyAweDU5YmFlZCBpbiB2b2lkIGhiX2J1ZmZlcl9hZGRfdXRmPGhiX3V0ZjhfdD4oaGJfYnVmZmVyX3QqLCBoYl91dGY4X3Q6OmNvZGVwb2ludF90IGNvbnN0KiwgaW50LCB1bnNpZ25lZCBpbnQsIGludCkgL3NyYy9oYXJmYnV6ei9zcmMvaGItYnVmZmVyLmNjOjE0OTI6MTENCiAgICAjNCAweDRhMjY2MSBpbiBMTFZNRnV6emVyVGVzdE9uZUlucHV0IC9zcmMvaGFyZmJ1enovLi90ZXN0L2Z1enppbmcvaGItc2hhcGUtZnV6emVyLmNjOjE4OjUNCiAgICAjNSAweDRlYWRhYiBpbiBmdXp6ZXI6OkZ1enplcjo6RXhlY3V0ZUNhbGxiYWNrKHVuc2lnbmVkIGNoYXIgY29uc3QqLCB1bnNpZ25lZCBsb25nKSAvc3JjL2xpYmZ1enplci9GdXp6ZXJMb29wLmNwcDo1NzA6MTUNCiAgICAjNiAweDRhM2FmNiBpbiBmdXp6ZXI6OlJ1bk9uZVRlc3QoZnV6emVyOjpGdXp6ZXIqLCBjaGFyIGNvbnN0KiwgdW5zaWduZWQgbG9uZykgL3NyYy9saWJmdXp6ZXIvRnV6emVyRHJpdmVyLmNwcDoyODA6Ng0KICAgICM3IDB4NGI0OTFhIGluIGZ1enplcjo6RnV6emVyRHJpdmVyKGludCosIGNoYXIqKiosIGludCAoKikodW5zaWduZWQgY2hhciBjb25zdCosIHVuc2lnbmVkIGxvbmcpKSAvc3JjL2xpYmZ1enplci9GdXp6ZXJEcml2ZXIuY3BwOjcxMzo5DQogICAgIzggMHg0YTJjMjEgaW4gbWFpbiAvc3JjL2xpYmZ1enplci9GdXp6ZXJNYWluLmNwcDoyMDoxMA0KICAgICM5IDB4N2ZmZmY2ZWU1ODJmIGluIF9fbGliY19zdGFydF9tYWluICgvbGliL3g4Nl82NC1saW51eC1nbnUvbGliYy5zby42KzB4MjA4MmYpDQoNCkRFRFVQX1RPS0VOOiByZWFsbG9jLS1oYl9idWZmZXJfdDo6ZW5sYXJnZSh1bnNpZ25lZCBpbnQpLS1oYl9idWZmZXJfdDo6ZW5zdXJlKHVuc2lnbmVkIGludCkNClNVTU1BUlk6IE1lbW9yeVNhbml0aXplcjogdXNlLW9mLXVuaW5pdGlhbGl6ZWQtdmFsdWUgL3NyYy9oYXJmYnV6ei9zcmMvLi9oYi1tYWNoaW5lcnkuaGg6Mjg2OjI1IGluIGhiX3Nhbml0aXplX2NvbnRleHRfdDo6Y2hlY2tfcmFuZ2Uodm9pZCBjb25zdCosIHVuc2lnbmVkIGludCkgY29uc3QNClVuaXF1ZSBoZWFwIG9yaWdpbnM6IDM3DQpTdGFjayBkZXBvdCBhbGxvY2F0ZWQgYnl0ZXM6IDI0NDgNClVuaXF1ZSBvcmlnaW4gaGlzdG9yaWVzOiA2DQpIaXN0b3J5IGRlcG90IGFsbG9jYXRlZCBieXRlczogMTQ0DQpFeGl0aW5n",
  "requested_content": {
    "/src/harfbuzz/src/hb-buffer.cc": {
      "108": "line  108 : ",
      "109": "line  109 : /* Internal API */",
      "110": "line  110 : ",
      "111": "line  111 : bool",
      "112": "line  112 : hb_buffer_t::enlarge (unsigned int size)",
      "113": "line  113 : {",
      "114": "line  114 :   if (unlikely (!successful))",
      "115": "line  115 :     return false;",
      "116": "line  116 :   if (unlikely (size > max_len))",
      "117": "line  117 :   {",
      "118": "line  118 :     successful = false;",
      "119": "line  119 :     return false;",
      "120": "line  120 :   }",
      "121": "line  121 : ",
      "122": "line  122 :   unsigned int new_allocated = allocated;",
      "123": "line  123 :   hb_glyph_position_t *new_pos = nullptr;",
      "124": "line  124 :   hb_glyph_info_t *new_info = nullptr;",
      "125": "line  125 :   bool separate_out = out_info != info;",
      "126": "line  126 : ",
      "127": "line  127 :   if (unlikely (hb_unsigned_mul_overflows (size, sizeof (info[0]))))",
      "128": "line  128 :     goto done;",
      "129": "line  129 : ",
      "130": "line  130 :   while (size >= new_allocated)",
      "131": "line  131 :     new_allocated += (new_allocated >> 1) + 32;",
      "132": "line  132 : ",
      "133": "line  133 :   static_assert ((sizeof (info[0]) == sizeof (pos[0])), \"\");",
      "134": "line  134 :   if (unlikely (hb_unsigned_mul_overflows (new_allocated, sizeof (info[0]))))",
      "135": "line  135 :     goto done;",
      "136": "line  136 : ",
      "137": "line  137 :   new_pos = (hb_glyph_position_t *) realloc (pos, new_allocated * sizeof (pos[0]));",
      "138": "line  138 :   new_info = (hb_glyph_info_t *) realloc (info, new_allocated * sizeof (info[0]));",
      "139": "line  139 : ",
      "140": "line  140 : done:",
      "141": "line  141 :   if (unlikely (!new_pos || !new_info))",
      "142": "line  142 :     successful = false;",
      "143": "line  143 : ",
      "144": "line  144 :   if (likely (new_pos))",
      "145": "line  145 :     pos = new_pos;",
      "146": "line  146 : ",
      "147": "line  147 :   if (likely (new_info))",
      "148": "line  148 :     info = new_info;",
      "149": "line  149 : ",
      "150": "line  150 :   out_info = separate_out ? (hb_glyph_info_t *) pos : info;",
      "151": "line  151 :   if (likely (successful))",
      "152": "line  152 :     allocated = new_allocated;",
      "153": "line  153 : ",
      "154": "line  154 :   return likely (successful);",
      "155": "line  155 : }",
      "156": "line  156 : ",
      "157": "line  157 : bool",
      "158": "line  158 : hb_buffer_t::make_room_for (unsigned int num_in,",
      "159": "line  159 : \t\t\t    unsigned int num_out)",
      "160": "line  160 : {",
      "161": "line  161 :   if (unlikely (!ensure (out_len + num_out))) return false;",
      "162": "line  162 : ",
      "163": "line  163 :   if (out_info == info &&",
      "164": "line  164 :       out_len + num_out > idx + num_in)",
      "165": "line  165 :   {",
      "166": "line  166 :     assert (have_output);",
      "167": "line  167 : ",
      "1979": "line 1979 : <End of File>"
    }
  },
  "note": [
    "Reason for requesting line 138 of /src/harfbuzz/src/hb-buffer.cc: Investigate memory allocation and initialization in `hb_buffer_t::enlarge` to understand how uninitialized memory might be introduced."
  ],
  "valid_patches": [
    {
      "file": "/src/harfbuzz/src/hb-buffer.cc",
      "diff": [
        {
          "line_number": 148,
          "content": [
            "    info = new_info;",
            "    if (new_allocated > old_allocated) {",
            "        memset ((char *) info + old_allocated * sizeof (info[0]), 0, (new_allocated - old_allocated) * sizeof (info[0]));",
            "    }"
          ]
        },
        {
          "line_number": 145,
          "content": [
            "    pos = new_pos;",
            "    unsigned int old_allocated = allocated;",
            "    if (new_allocated > old_allocated) {",
            "        memset ((char *) pos + old_allocated * sizeof (pos[0]), 0, (new_allocated - old_allocated) * sizeof (pos[0]));",
            "    }"
          ]
        }
      ]
    }
  ],
  "retry_count": 6,
  "history": [
    {
      "reason": "Investigate memory allocation and initialization in `hb_buffer_t::enlarge` to understand how uninitialized memory might be introduced.",
      "line": 138,
      "file": "/src/harfbuzz/src/hb-buffer.cc"
    },
    {
      "reason": "The `realloc` call for `info` can return a larger memory block with uninitialized bytes. These uninitialized bytes are later accessed by `OT::IntType<unsigned short, 2u>::sanitize`, leading to a MemorySanitizer error. The fix is to zero-initialize the newly allocated portion of the `info` array to prevent reading uninitialized memory.",
      "patches": [
        {
          "file": "/src/harfbuzz/src/hb-buffer.cc",
          "diff": [
            {
              "line_number": 149,
              "content": [
                "  if (likely (new_info))",
                "  {",
                "    if (new_info != info && info)",
                "      memset (new_info + allocated, 0, (new_allocated - allocated) * sizeof (new_info[0]));",
                "    else if (!info)",
                "      memset (new_info, 0, new_allocated * sizeof (new_info[0]));",
                "    info = new_info;",
                "  }"
              ]
            }
          ]
        }
      ]
    },
    {
      "reason": "The `realloc` calls in `hb_buffer_t::enlarge` can return uninitialized memory when the buffer grows. This uninitialized memory is later accessed by the sanitizer, leading to a crash. The fix is to zero-initialize the newly allocated portions of `pos` and `info` arrays after successful reallocation.",
      "patches": [
        {
          "file": "/src/harfbuzz/src/hb-buffer.cc",
          "diff": [
            {
              "line_number": 149,
              "content": [
                "  if (likely (new_info))",
                "  {",
                "    unsigned int old_allocated = allocated;",
                "    info = new_info;",
                "    if (new_allocated > old_allocated)",
                "      memset (info + old_allocated, 0, (new_allocated - old_allocated) * sizeof (info[0]));",
                "  }",
                "",
                "  if (likely (new_pos))",
                "  {",
                "    unsigned int old_allocated = allocated; /* Use the same old_allocated as info, as pos and info are resized together */",
                "    pos = new_pos;",
                "    if (new_allocated > old_allocated)",
                "      memset (pos + old_allocated, 0, (new_allocated - old_allocated) * sizeof (pos[0]));",
                "  }"
              ]
            }
          ]
        }
      ]
    },
    {
      "reason": "The `realloc` calls in `hb_buffer_t::enlarge` can return a larger block of memory with the newly added portion uninitialized. The crash report confirms a 'use-of-uninitialized-value' originating from these `realloc` calls during subsequent sanitization checks. The proposed fix initializes the newly allocated memory for `info` and `pos` to zero using `memset` after successful reallocation, preventing reads of uninitialized data.",
      "patches": [
        {
          "file": "/src/harfbuzz/src/hb-buffer.cc",
          "diff": [
            {
              "line_number": 149,
              "content": [
                "  if (likely (successful))",
                "  {",
                "    if (new_allocated > allocated)",
                "    {",
                "      memset (info + allocated, 0, (new_allocated - allocated) * sizeof (info[0]));",
                "      memset (pos + allocated, 0, (new_allocated - allocated) * sizeof (pos[0]));",
                "    }",
                "    allocated = new_allocated;",
                "  }",
                ""
              ]
            }
          ]
        }
      ]
    },
    {
      "reason": "The `hb_buffer_t::enlarge` function reallocates memory for `pos` and `info` arrays. However, if `realloc` expands the memory block, the newly allocated portion is not initialized. This leads to `use-of-uninitialized-value` when these uninitialized parts of the buffer are later accessed and sanitized. The fix is to zero-initialize the newly added memory regions after successful reallocation.",
      "patches": [
        {
          "file": "/src/harfbuzz/src/hb-buffer.cc",
          "diff": [
            {
              "line_number": 146,
              "content": [
                "    pos = new_pos;",
                "    if (new_allocated > old_allocated)",
                "      memset (pos + old_allocated, 0, (new_allocated - old_allocated) * sizeof (pos[0]));"
              ]
            },
            {
              "line_number": 149,
              "content": [
                "    info = new_info;",
                "    if (new_allocated > old_allocated)",
                "      memset (info + old_allocated, 0, (new_allocated - old_allocated) * sizeof (info[0]));"
              ]
            },
            {
              "line_number": 151,
              "content": [
                "  out_info = separate_out ? (hb_glyph_info_t *) pos : info;",
                "  if (likely (successful)) {",
                "    old_allocated = allocated; /* save old value for memset above */",
                "    allocated = new_allocated;",
                "  }"
              ]
            }
          ]
        }
      ]
    },
    {
      "reason": "The `realloc` calls in `hb_buffer_t::enlarge` can return memory that is uninitialized in the newly expanded portion. This leads to a `use-of-uninitialized-value` error when this uninitialized memory is later accessed by `sanitize` functions. The fix is to zero-initialize the newly allocated memory for both `info` and `pos` arrays after a successful reallocation.",
      "patches": [
        {
          "file": "/src/harfbuzz/src/hb-buffer.cc",
          "diff": [
            {
              "line_number": 148,
              "content": [
                "    info = new_info;",
                "    if (new_allocated > old_allocated) {",
                "        memset ((char *) info + old_allocated * sizeof (info[0]), 0, (new_allocated - old_allocated) * sizeof (info[0]));",
                "    }"
              ]
            },
            {
              "line_number": 145,
              "content": [
                "    pos = new_pos;",
                "    unsigned int old_allocated = allocated;",
                "    if (new_allocated > old_allocated) {",
                "        memset ((char *) pos + old_allocated * sizeof (pos[0]), 0, (new_allocated - old_allocated) * sizeof (pos[0]));",
                "    }"
              ]
            }
          ]
        }
      ]
    }
  ]
}