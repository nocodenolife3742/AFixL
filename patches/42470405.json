{
  "id": "42470405",
  "stage": "evaluate",
  "repo_addr": "https://github.com/harfbuzz/harfbuzz.git",
  "fix_commit": "f8ccb545c47abe8f0f4ed318ff7b5bf176913893",
  "project": "harfbuzz",
  "report": "V0FSTklORzogTWVtb3J5U2FuaXRpemVyOiB1c2Utb2YtdW5pbml0aWFsaXplZC12YWx1ZQ0KICAgICMwIDB4NWJkMzIyIGluIGludCBPVDo6SW50VHlwZTx1bnNpZ25lZCBpbnQsIDR1Pjo6Y21wPE9UOjpUYWc-KE9UOjpUYWcpIGNvbnN0IC9zcmMvaGFyZmJ1enovc3JjLy4vaGItb3Blbi10eXBlLmhoOjcxOjE0DQogICAgIzEgMHg1YmQwODAgaW4gT1Q6OlRhYmxlUmVjb3JkOjpjbXAoT1Q6OlRhZykgY29uc3QgL3NyYy9oYXJmYnV6ei9zcmMvLi9oYi1vcGVuLWZpbGUuaGg6NTg6MTUNCiAgICAjMiAweDViY2M0NCBpbiBpbnQgT1Q6OlNvcnRlZEFycmF5T2Y8T1Q6OlRhYmxlUmVjb3JkLCBPVDo6QmluU2VhcmNoSGVhZGVyPjo6YnNlYXJjaDxPVDo6VGFnPihPVDo6VGFnIGNvbnN0JikgY29uc3QgL3NyYy9oYXJmYnV6ei9zcmMvLi9oYi1vcGVuLXR5cGUuaGg6Njg4OjI0DQogICAgIzMgMHg1YmM1MzUgaW4gT1Q6Ok9mZnNldFRhYmxlOjpmaW5kX3RhYmxlX2luZGV4KHVuc2lnbmVkIGludCwgdW5zaWduZWQgaW50KikgY29uc3QgL3NyYy9oYXJmYnV6ei9zcmMvLi9oYi1vcGVuLWZpbGUuaGg6MTE2OjU5DQogICAgIzQgMHg1YmMzMDkgaW4gT1Q6Ok9mZnNldFRhYmxlOjpnZXRfdGFibGVfYnlfdGFnKHVuc2lnbmVkIGludCkgY29uc3QgL3NyYy9oYXJmYnV6ei9zcmMvLi9oYi1vcGVuLWZpbGUuaGg6MTI0OjUNCiAgICAjNSAweDViNGY4YyBpbiBfaGJfZmFjZV9mb3JfZGF0YV9yZWZlcmVuY2VfdGFibGUoaGJfZmFjZV90KiwgdW5zaWduZWQgaW50LCB2b2lkKikgL3NyYy9oYXJmYnV6ei9zcmMvaGItZmFjZS5jYzoxNjk6NDQNCiAgICAjNiAweDViYTQxNyBpbiBoYl9mYWNlX3Q6OnJlZmVyZW5jZV90YWJsZSh1bnNpZ25lZCBpbnQpIGNvbnN0IC9zcmMvaGFyZmJ1enovc3JjLy4vaGItZmFjZS5oaDo3NDoxMg0KICAgICM3IDB4NzEwOTMzIGluIGhiX2Jsb2JfdCogaGJfc2FuaXRpemVfY29udGV4dF90OjpyZWZlcmVuY2VfdGFibGU8T1Q6OkdTVUI-KGhiX2ZhY2VfdCBjb25zdCosIHVuc2lnbmVkIGludCkgL3NyYy9oYXJmYnV6ei9zcmMvLi9oYi1tYWNoaW5lcnkuaGg6NDIxOjMzDQogICAgIzggMHg3MTAzYjAgaW4gT1Q6OkdTVUJHUE9TOjphY2NlbGVyYXRvcl90PE9UOjpHU1VCPjo6aW5pdChoYl9mYWNlX3QqKSAvc3JjL2hhcmZidXp6L3NyYy8uL2hiLW90LWxheW91dC1nc3ViZ3Bvcy5oaDoyNjUzOjQ0DQogICAgIzkgMHg3MTAyNzEgaW4gaGJfbGF6eV9sb2FkZXJfdDxPVDo6R1NVQl9hY2NlbGVyYXRvcl90LCBoYl9mYWNlX2xhenlfbG9hZGVyX3Q8T1Q6OkdTVUJfYWNjZWxlcmF0b3JfdCwgMTJ1PiwgaGJfZmFjZV90LCAxMnUsIE9UOjpHU1VCX2FjY2VsZXJhdG9yX3Q-OjpjcmVhdGUoaGJfZmFjZV90KikgL3NyYy9oYXJmYnV6ei9zcmMvLi9oYi1tYWNoaW5lcnkuaGg6ODI1OjEwDQogICAgIzEwIDB4NzEwMTEyIGluIE9UOjpHU1VCX2FjY2VsZXJhdG9yX3QqIGhiX2RhdGFfd3JhcHBlcl90PGhiX2ZhY2VfdCwgMTJ1Pjo6Y2FsbF9jcmVhdGU8T1Q6OkdTVUJfYWNjZWxlcmF0b3JfdCwgaGJfZmFjZV9sYXp5X2xvYWRlcl90PE9UOjpHU1VCX2FjY2VsZXJhdG9yX3QsIDEydT4gPigpIGNvbnN0IC9zcmMvaGFyZmJ1enovc3JjLy4vaGItbWFjaGluZXJ5LmhoOjcxODoyOA0KICAgICMxMSAweDcwZmZiMiBpbiBoYl9sYXp5X2xvYWRlcl90PE9UOjpHU1VCX2FjY2VsZXJhdG9yX3QsIGhiX2ZhY2VfbGF6eV9sb2FkZXJfdDxPVDo6R1NVQl9hY2NlbGVyYXRvcl90LCAxMnU-LCBoYl9mYWNlX3QsIDEydSwgT1Q6OkdTVUJfYWNjZWxlcmF0b3JfdD46OmRvX2NyZWF0ZSgpIGNvbnN0IC9zcmMvaGFyZmJ1enovc3JjLy4vaGItbWFjaGluZXJ5LmhoOjc2MjozMg0KICAgICMxMiAweDcwZmU1YyBpbiBoYl9sYXp5X2xvYWRlcl90PE9UOjpHU1VCX2FjY2VsZXJhdG9yX3QsIGhiX2ZhY2VfbGF6eV9sb2FkZXJfdDxPVDo6R1NVQl9hY2NlbGVyYXRvcl90LCAxMnU-LCBoYl9mYWNlX3QsIDEydSwgT1Q6OkdTVUJfYWNjZWxlcmF0b3JfdD46OmdldF9zdG9yZWQoKSBjb25zdCAvc3JjL2hhcmZidXp6L3NyYy8uL2hiLW1hY2hpbmVyeS5oaDo3ODc6MTENCiAgICAjMTMgMHg3MGZjZjEgaW4gaGJfbGF6eV9sb2FkZXJfdDxPVDo6R1NVQl9hY2NlbGVyYXRvcl90LCBoYl9mYWNlX2xhenlfbG9hZGVyX3Q8T1Q6OkdTVUJfYWNjZWxlcmF0b3JfdCwgMTJ1PiwgaGJfZmFjZV90LCAxMnUsIE9UOjpHU1VCX2FjY2VsZXJhdG9yX3Q-OjpnZXQoKSBjb25zdCAvc3JjL2hhcmZidXp6L3NyYy8uL2hiLW1hY2hpbmVyeS5oaDo4MTI6NjkNCiAgICAjMTQgMHg2YjkwNTMgaW4gX2dldF9nc3ViKGhiX2ZhY2VfdCopIC9zcmMvaGFyZmJ1enovc3JjL2hiLW90LWxheW91dC5jYzo3MjoxMQ0KICAgICMxNSAweDZiNTA0ZiBpbiBnZXRfZ3N1Ymdwb3NfdGFibGUoaGJfZmFjZV90KiwgdW5zaWduZWQgaW50KSAvc3JjL2hhcmZidXp6L3NyYy9oYi1vdC1sYXlvdXQuY2M6Mjk2OjMzDQogICAgIzE2IDB4NmI1NDkxIGluIGhiX290X2xheW91dF90YWJsZV9jaG9vc2Vfc2NyaXB0IC9zcmMvaGFyZmJ1enovc3JjL2hiLW90LWxheW91dC5jYzozNTU6MjcNCiAgICAjMTcgMHg3NjJjYjggaW4gaGJfb3RfbWFwX2J1aWxkZXJfdDo6aGJfb3RfbWFwX2J1aWxkZXJfdChoYl9mYWNlX3QqLCBoYl9zZWdtZW50X3Byb3BlcnRpZXNfdCBjb25zdCopIC9zcmMvaGFyZmJ1enovc3JjL2hiLW90LW1hcC5jYzo2NTo0MA0KICAgICMxOCAweDYyOTAxMSBpbiBfaGJfb3Rfc2hhcGVyX3NoYXBlX3BsYW5fZGF0YV9jcmVhdGUgL3NyYy9oYXJmYnV6ei9zcmMvaGItb3Qtc2hhcGUuY2M6MTkwOjI1DQogICAgIzE5IDB4NWYwYzQ4IGluIGhiX3NoYXBlX3BsYW5fcGxhbihoYl9zaGFwZV9wbGFuX3QqLCBoYl9mZWF0dXJlX3QgY29uc3QqLCB1bnNpZ25lZCBpbnQsIGludCBjb25zdCosIHVuc2lnbmVkIGludCwgY2hhciBjb25zdCogY29uc3QqKSAvc3JjL2hhcmZidXp6L3NyYy8uL2hiLXNoYXBlci1saXN0LmhoOjQzOjENCiAgICAjMjAgMHg1ZjA1YzcgaW4gaGJfc2hhcGVfcGxhbl9jcmVhdGUyIC9zcmMvaGFyZmJ1enovc3JjL2hiLXNoYXBlLXBsYW4uY2M6MTk4OjMNCiAgICAjMjEgMHg1ZjM0OGMgaW4gaGJfc2hhcGVfcGxhbl9jcmVhdGVfY2FjaGVkMiAvc3JjL2hhcmZidXp6L3NyYy9oYi1zaGFwZS1wbGFuLmNjOjUzNDozMw0KICAgICMyMiAweDVlZjJiMiBpbiBoYl9zaGFwZV9mdWxsIC9zcmMvaGFyZmJ1enovc3JjL2hiLXNoYXBlLmNjOjEzNzozMw0KICAgICMyMyAweDRhMjYxNiBpbiBMTFZNRnV6emVyVGVzdE9uZUlucHV0IC9zcmMvaGFyZmJ1enovLi90ZXN0L2Z1enppbmcvaGItc2hhcGUtZnV6emVyLmNjOjIwOjUNCiAgICAjMjQgMHg0ZWE2NzYgaW4gZnV6emVyOjpGdXp6ZXI6OkV4ZWN1dGVDYWxsYmFjayh1bnNpZ25lZCBjaGFyIGNvbnN0KiwgdW5zaWduZWQgbG9uZykgL3NyYy9saWJmdXp6ZXIvRnV6emVyTG9vcC5jcHA6NTcwOjE1DQogICAgIzI1IDB4NGEzYTU2IGluIGZ1enplcjo6UnVuT25lVGVzdChmdXp6ZXI6OkZ1enplciosIGNoYXIgY29uc3QqLCB1bnNpZ25lZCBsb25nKSAvc3JjL2xpYmZ1enplci9GdXp6ZXJEcml2ZXIuY3BwOjI4MDo2DQogICAgIzI2IDB4NGI0NGRiIGluIGZ1enplcjo6RnV6emVyRHJpdmVyKGludCosIGNoYXIqKiosIGludCAoKikodW5zaWduZWQgY2hhciBjb25zdCosIHVuc2lnbmVkIGxvbmcpKSAvc3JjL2xpYmZ1enplci9GdXp6ZXJEcml2ZXIuY3BwOjcxMzo5DQogICAgIzI3IDB4NGEyYjgxIGluIG1haW4gL3NyYy9saWJmdXp6ZXIvRnV6emVyTWFpbi5jcHA6MjA6MTANCiAgICAjMjggMHg3ZmZmZjZlZTU4MmYgaW4gX19saWJjX3N0YXJ0X21haW4gKC9saWIveDg2XzY0LWxpbnV4LWdudS9saWJjLnNvLjYrMHgyMDgyZikNCiAgICAjMjkgMHg0MWVmMjggaW4gX3N0YXJ0ICgvb3V0L2hiLXNoYXBlLWZ1enplcisweDQxZWYyOCkNCg0KREVEVVBfVE9LRU46IGludCBPVDo6SW50VHlwZTx1bnNpZ25lZCBpbnQsIDR1Pjo6Y21wPE9UOjpUYWc-KE9UOjpUYWcpIGNvbnN0LS1PVDo6VGFibGVSZWNvcmQ6OmNtcChPVDo6VGFnKSBjb25zdC0taW50IE9UOjpTb3J0ZWRBcnJheU9mPE9UOjpUYWJsZVJlY29yZCwgT1Q6OkJpblNlYXJjaEhlYWRlcj46OmJzZWFyY2g8T1Q6OlRhZz4oT1Q6OlRhZyBjb25zdCYpIGNvbnN0DQogIFVuaW5pdGlhbGl6ZWQgdmFsdWUgd2FzIHN0b3JlZCB0byBtZW1vcnkgYXQNCiAgICAjMCAweDViZDJmNSBpbiBpbnQgT1Q6OkludFR5cGU8dW5zaWduZWQgaW50LCA0dT46OmNtcDxPVDo6VGFnPihPVDo6VGFnKSBjb25zdCAvc3JjL2hhcmZidXp6L3NyYy8uL2hiLW9wZW4tdHlwZS5oaA0KICAgICMxIDB4NWJkMDgwIGluIE9UOjpUYWJsZVJlY29yZDo6Y21wKE9UOjpUYWcpIGNvbnN0IC9zcmMvaGFyZmJ1enovc3JjLy4vaGItb3Blbi1maWxlLmhoOjU4OjE1DQogICAgIzIgMHg1YmNjNDQgaW4gaW50IE9UOjpTb3J0ZWRBcnJheU9mPE9UOjpUYWJsZVJlY29yZCwgT1Q6OkJpblNlYXJjaEhlYWRlcj46OmJzZWFyY2g8T1Q6OlRhZz4oT1Q6OlRhZyBjb25zdCYpIGNvbnN0IC9zcmMvaGFyZmJ1enovc3JjLy4vaGItb3Blbi10eXBlLmhoOjY4ODoyNA0KICAgICMzIDB4NWJjNTM1IGluIE9UOjpPZmZzZXRUYWJsZTo6ZmluZF90YWJsZV9pbmRleCh1bnNpZ25lZCBpbnQsIHVuc2lnbmVkIGludCopIGNvbnN0IC9zcmMvaGFyZmJ1enovc3JjLy4vaGItb3Blbi1maWxlLmhoOjExNjo1OQ0KICAgICM0IDB4NWJjMzA5IGluIE9UOjpPZmZzZXRUYWJsZTo6Z2V0X3RhYmxlX2J5X3RhZyh1bnNpZ25lZCBpbnQpIGNvbnN0IC9zcmMvaGFyZmJ1enovc3JjLy4vaGItb3Blbi1maWxlLmhoOjEyNDo1DQogICAgIzUgMHg1YjRmOGMgaW4gX2hiX2ZhY2VfZm9yX2RhdGFfcmVmZXJlbmNlX3RhYmxlKGhiX2ZhY2VfdCosIHVuc2lnbmVkIGludCwgdm9pZCopIC9zcmMvaGFyZmJ1enovc3JjL2hiLWZhY2UuY2M6MTY5OjQ0DQogICAgIzYgMHg1YmE0MTcgaW4gaGJfZmFjZV90OjpyZWZlcmVuY2VfdGFibGUodW5zaWduZWQgaW50KSBjb25zdCAvc3JjL2hhcmZidXp6L3NyYy8uL2hiLWZhY2UuaGg6NzQ6MTINCiAgICAjNyAweDcxMDkzMyBpbiBoYl9ibG9iX3QqIGhiX3Nhbml0aXplX2NvbnRleHRfdDo6cmVmZXJlbmNlX3RhYmxlPE9UOjpHU1VCPihoYl9mYWNlX3QgY29uc3QqLCB1bnNpZ25lZCBpbnQpIC9zcmMvaGFyZmJ1enovc3JjLy4vaGItbWFjaGluZXJ5LmhoOjQyMTozMw0KICAgICM4IDB4NzEwM2IwIGluIE9UOjpHU1VCR1BPUzo6YWNjZWxlcmF0b3JfdDxPVDo6R1NVQj46OmluaXQoaGJfZmFjZV90KikgL3NyYy9oYXJmYnV6ei9zcmMvLi9oYi1vdC1sYXlvdXQtZ3N1Ymdwb3MuaGg6MjY1Mzo0NA0KICAgICM5IDB4NzEwMjcxIGluIGhiX2xhenlfbG9hZGVyX3Q8T1Q6OkdTVUJfYWNjZWxlcmF0b3JfdCwgaGJfZmFjZV9sYXp5X2xvYWRlcl90PE9UOjpHU1VCX2FjY2VsZXJhdG9yX3QsIDEydT4sIGhiX2ZhY2VfdCwgMTJ1LCBPVDo6R1NVQl9hY2NlbGVyYXRvcl90Pjo6Y3JlYXRlKGhiX2ZhY2VfdCopIC9zcmMvaGFyZmJ1enovc3JjLy4vaGItbWFjaGluZXJ5LmhoOjgyNToxMA0KICAgICMxMCAweDcxMDExMiBpbiBPVDo6R1NVQl9hY2NlbGVyYXRvcl90KiBoYl9kYXRhX3dyYXBwZXJfdDxoYl9mYWNlX3QsIDEydT46OmNhbGxfY3JlYXRlPE9UOjpHU1VCX2FjY2VsZXJhdG9yX3QsIGhiX2ZhY2VfbGF6eV9sb2FkZXJfdDxPVDo6R1NVQl9hY2NlbGVyYXRvcl90LCAxMnU-ID4oKSBjb25zdCAvc3JjL2hhcmZidXp6L3NyYy8uL2hiLW1hY2hpbmVyeS5oaDo3MTg6MjgNCiAgICAjMTEgMHg3MGZmYjIgaW4gaGJfbGF6eV9sb2FkZXJfdDxPVDo6R1NVQl9hY2NlbGVyYXRvcl90LCBoYl9mYWNlX2xhenlfbG9hZGVyX3Q8T1Q6OkdTVUJfYWNjZWxlcmF0b3JfdCwgMTJ1PiwgaGJfZmFjZV90LCAxMnUsIE9UOjpHU1VCX2FjY2VsZXJhdG9yX3Q-Ojpkb19jcmVhdGUoKSBjb25zdCAvc3JjL2hhcmZidXp6L3NyYy8uL2hiLW1hY2hpbmVyeS5oaDo3NjI6MzINCiAgICAjMTIgMHg3MGZlNWMgaW4gaGJfbGF6eV9sb2FkZXJfdDxPVDo6R1NVQl9hY2NlbGVyYXRvcl90LCBoYl9mYWNlX2xhenlfbG9hZGVyX3Q8T1Q6OkdTVUJfYWNjZWxlcmF0b3JfdCwgMTJ1PiwgaGJfZmFjZV90LCAxMnUsIE9UOjpHU1VCX2FjY2VsZXJhdG9yX3Q-OjpnZXRfc3RvcmVkKCkgY29uc3QgL3NyYy9oYXJmYnV6ei9zcmMvLi9oYi1tYWNoaW5lcnkuaGg6Nzg3OjExDQogICAgIzEzIDB4NzBmY2YxIGluIGhiX2xhenlfbG9hZGVyX3Q8T1Q6OkdTVUJfYWNjZWxlcmF0b3JfdCwgaGJfZmFjZV9sYXp5X2xvYWRlcl90PE9UOjpHU1VCX2FjY2VsZXJhdG9yX3QsIDEydT4sIGhiX2ZhY2VfdCwgMTJ1LCBPVDo6R1NVQl9hY2NlbGVyYXRvcl90Pjo6Z2V0KCkgY29uc3QgL3NyYy9oYXJmYnV6ei9zcmMvLi9oYi1tYWNoaW5lcnkuaGg6ODEyOjY5DQogICAgIzE0IDB4NmI5MDUzIGluIF9nZXRfZ3N1YihoYl9mYWNlX3QqKSAvc3JjL2hhcmZidXp6L3NyYy9oYi1vdC1sYXlvdXQuY2M6NzI6MTENCiAgICAjMTUgMHg2YjUwNGYgaW4gZ2V0X2dzdWJncG9zX3RhYmxlKGhiX2ZhY2VfdCosIHVuc2lnbmVkIGludCkgL3NyYy9oYXJmYnV6ei9zcmMvaGItb3QtbGF5b3V0LmNjOjI5NjozMw0KICAgICMxNiAweDZiNTQ5MSBpbiBoYl9vdF9sYXlvdXRfdGFibGVfY2hvb3NlX3NjcmlwdCAvc3JjL2hhcmZidXp6L3NyYy9oYi1vdC1sYXlvdXQuY2M6MzU1OjI3DQogICAgIzE3IDB4NzYyY2I4IGluIGhiX290X21hcF9idWlsZGVyX3Q6OmhiX290X21hcF9idWlsZGVyX3QoaGJfZmFjZV90KiwgaGJfc2VnbWVudF9wcm9wZXJ0aWVzX3QgY29uc3QqKSAvc3JjL2hhcmZidXp6L3NyYy9oYi1vdC1tYXAuY2M6NjU6NDANCiAgICAjMTggMHg2MjkwMTEgaW4gX2hiX290X3NoYXBlcl9zaGFwZV9wbGFuX2RhdGFfY3JlYXRlIC9zcmMvaGFyZmJ1enovc3JjL2hiLW90LXNoYXBlLmNjOjE5MDoyNQ0KICAgICMxOSAweDVmMGM0OCBpbiBoYl9zaGFwZV9wbGFuX3BsYW4oaGJfc2hhcGVfcGxhbl90KiwgaGJfZmVhdHVyZV90IGNvbnN0KiwgdW5zaWduZWQgaW50LCBpbnQgY29uc3QqLCB1bnNpZ25lZCBpbnQsIGNoYXIgY29uc3QqIGNvbnN0KikgL3NyYy9oYXJmYnV6ei9zcmMvLi9oYi1zaGFwZXItbGlzdC5oaDo0MzoxDQoNCkRFRFVQX1RPS0VOOiBpbnQgT1Q6OkludFR5cGU8dW5zaWduZWQgaW50LCA0dT46OmNtcDxPVDo6VGFnPihPVDo6VGFnKSBjb25zdC0tT1Q6OlRhYmxlUmVjb3JkOjpjbXAoT1Q6OlRhZykgY29uc3QtLWludCBPVDo6U29ydGVkQXJyYXlPZjxPVDo6VGFibGVSZWNvcmQsIE9UOjpCaW5TZWFyY2hIZWFkZXI-Ojpic2VhcmNoPE9UOjpUYWc-KE9UOjpUYWcgY29uc3QmKSBjb25zdA0KICBVbmluaXRpYWxpemVkIHZhbHVlIHdhcyBjcmVhdGVkIGJ5IGEgaGVhcCBhbGxvY2F0aW9uDQogICAgIzAgMHg0NWVkYzUgaW4gcmVhbGxvYyAvc3JjL2xsdm0vcHJvamVjdHMvY29tcGlsZXItcnQvbGliL21zYW4vbXNhbl9pbnRlcmNlcHRvcnMuY2M6ODkyDQogICAgIzEgMHg1OTAyYTUgaW4gaGJfYnVmZmVyX3Q6OmVubGFyZ2UodW5zaWduZWQgaW50KSAvc3JjL2hhcmZidXp6L3NyYy9oYi1idWZmZXIuY2M6MTM3OjM3DQogICAgIzIgMHg1YTNhM2MgaW4gaGJfYnVmZmVyX3Q6OmVuc3VyZSh1bnNpZ25lZCBpbnQpIC9zcmMvaGFyZmJ1enovc3JjLy4vaGItYnVmZmVyLmhoOjI4MTo1Ng0KICAgICMzIDB4NTlhODkwIGluIHZvaWQgaGJfYnVmZmVyX2FkZF91dGY8aGJfdXRmOF90PihoYl9idWZmZXJfdCosIGhiX3V0ZjhfdDo6Y29kZXBvaW50X3QgY29uc3QqLCBpbnQsIHVuc2lnbmVkIGludCwgaW50KSAvc3JjL2hhcmZidXp6L3NyYy9oYi1idWZmZXIuY2M6MTUzNDoxMQ0KICAgICM0IDB4NGEyNWFlIGluIExMVk1GdXp6ZXJUZXN0T25lSW5wdXQgL3NyYy9oYXJmYnV6ei8uL3Rlc3QvZnV6emluZy9oYi1zaGFwZS1mdXp6ZXIuY2M6MTg6NQ0KICAgICM1IDB4NGVhNjc2IGluIGZ1enplcjo6RnV6emVyOjpFeGVjdXRlQ2FsbGJhY2sodW5zaWduZWQgY2hhciBjb25zdCosIHVuc2lnbmVkIGxvbmcpIC9zcmMvbGliZnV6emVyL0Z1enplckxvb3AuY3BwOjU3MDoxNQ0KICAgICM2IDB4NGEzYTU2IGluIGZ1enplcjo6UnVuT25lVGVzdChmdXp6ZXI6OkZ1enplciosIGNoYXIgY29uc3QqLCB1bnNpZ25lZCBsb25nKSAvc3JjL2xpYmZ1enplci9GdXp6ZXJEcml2ZXIuY3BwOjI4MDo2DQogICAgIzcgMHg0YjQ0ZGIgaW4gZnV6emVyOjpGdXp6ZXJEcml2ZXIoaW50KiwgY2hhcioqKiwgaW50ICgqKSh1bnNpZ25lZCBjaGFyIGNvbnN0KiwgdW5zaWduZWQgbG9uZykpIC9zcmMvbGliZnV6emVyL0Z1enplckRyaXZlci5jcHA6NzEzOjkNCiAgICAjOCAweDRhMmI4MSBpbiBtYWluIC9zcmMvbGliZnV6emVyL0Z1enplck1haW4uY3BwOjIwOjEwDQogICAgIzkgMHg3ZmZmZjZlZTU4MmYgaW4gX19saWJjX3N0YXJ0X21haW4gKC9saWIveDg2XzY0LWxpbnV4LWdudS9saWJjLnNvLjYrMHgyMDgyZikNCg0KREVEVVBfVE9LRU46IHJlYWxsb2MtLWhiX2J1ZmZlcl90OjplbmxhcmdlKHVuc2lnbmVkIGludCktLWhiX2J1ZmZlcl90OjplbnN1cmUodW5zaWduZWQgaW50KQ0KU1VNTUFSWTogTWVtb3J5U2FuaXRpemVyOiB1c2Utb2YtdW5pbml0aWFsaXplZC12YWx1ZSAvc3JjL2hhcmZidXp6L3NyYy8uL2hiLW9wZW4tdHlwZS5oaDo3MToxNCBpbiBpbnQgT1Q6OkludFR5cGU8dW5zaWduZWQgaW50LCA0dT46OmNtcDxPVDo6VGFnPihPVDo6VGFnKSBjb25zdA0KVW5pcXVlIGhlYXAgb3JpZ2luczogMzkNClN0YWNrIGRlcG90IGFsbG9jYXRlZCBieXRlczogMjc0NA0KVW5pcXVlIG9yaWdpbiBoaXN0b3JpZXM6IDcNCkhpc3RvcnkgZGVwb3QgYWxsb2NhdGVkIGJ5dGVzOiAxNjgNCkV4aXRpbmc=",
  "requested_content": {
    "/src/harfbuzz/./test/fuzzing/hb-shape-fuzzer.cc": {
      "1": "line    1 : #include \"hb-fuzzer.hh\"",
      "2": "line    2 : ",
      "3": "line    3 : #include <hb-ot.h>",
      "4": "line    4 : #include <string.h>",
      "5": "line    5 : ",
      "6": "line    6 : extern \"C\" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size)",
      "7": "line    7 : {",
      "8": "line    8 :   hb_blob_t *blob = hb_blob_create((const char *)data, size,",
      "9": "line    9 :                                    HB_MEMORY_MODE_READONLY, NULL, NULL);",
      "10": "line   10 :   hb_face_t *face = hb_face_create(blob, 0);",
      "11": "line   11 :   hb_font_t *font = hb_font_create(face);",
      "12": "line   12 :   hb_ot_font_set_funcs(font);",
      "13": "line   13 :   hb_font_set_scale(font, 12, 12);",
      "14": "line   14 : ",
      "15": "line   15 :   {",
      "16": "line   16 :     const char text[] = \"ABCDEXYZ123@_%&)*$!\";",
      "17": "line   17 :     hb_buffer_t *buffer = hb_buffer_create();",
      "18": "line   18 :     hb_buffer_add_utf8(buffer, text, -1, 0, -1);",
      "19": "line   19 :     hb_buffer_guess_segment_properties(buffer);",
      "20": "line   20 :     hb_shape(font, buffer, NULL, 0);",
      "21": "line   21 :     hb_buffer_destroy(buffer);",
      "22": "line   22 :   }",
      "23": "line   23 : ",
      "24": "line   24 :   uint32_t text32[16];",
      "25": "line   25 :   if (size > sizeof(text32)) {",
      "26": "line   26 :     memcpy(text32, data + size - sizeof(text32), sizeof(text32));",
      "27": "line   27 :     hb_buffer_t *buffer = hb_buffer_create();",
      "28": "line   28 :     hb_buffer_add_utf32(buffer, text32, sizeof(text32)/sizeof(text32[0]), 0, -1);",
      "29": "line   29 :     hb_buffer_guess_segment_properties(buffer);",
      "30": "line   30 :     hb_shape(font, buffer, NULL, 0);",
      "31": "line   31 : ",
      "32": "line   32 :     unsigned int len = hb_buffer_get_length (buffer);",
      "33": "line   33 :     hb_glyph_info_t *infos = hb_buffer_get_glyph_infos (buffer, NULL);",
      "34": "line   34 :     //hb_glyph_position_t *positions = hb_buffer_get_glyph_positions (buffer, NULL);",
      "35": "line   35 :     for (unsigned int i = 0; i < len; i++)",
      "36": "line   36 :     {",
      "37": "line   37 :       hb_glyph_info_t info = infos[i];",
      "38": "line   38 :       //hb_glyph_position_t pos = positions[i];",
      "39": "line   39 : ",
      "40": "line   40 :       hb_glyph_extents_t extents;",
      "41": "line   41 :       hb_font_get_glyph_extents (font, info.codepoint, &extents);",
      "42": "line   42 :     }",
      "43": "line   43 : ",
      "44": "line   44 :     hb_buffer_destroy(buffer);",
      "45": "line   45 :   }",
      "46": "line   46 : ",
      "47": "line   47 : ",
      "54": "line   54 : <End of File>"
    },
    "/src/harfbuzz/src/./hb-open-type.hh": {
      "41": "line   41 : ",
      "42": "line   42 : /*",
      "43": "line   43 :  *",
      "44": "line   44 :  * The OpenType Font File: Data Types",
      "45": "line   45 :  */",
      "46": "line   46 : ",
      "47": "line   47 : ",
      "48": "line   48 : /* \"The following data types are used in the OpenType font file.",
      "49": "line   49 :  *  All OpenType fonts use Motorola-style byte ordering (Big Endian):\" */",
      "50": "line   50 : ",
      "51": "line   51 : /*",
      "52": "line   52 :  * Int types",
      "53": "line   53 :  */",
      "54": "line   54 : ",
      "55": "line   55 : /* Integer types in big-endian order and no alignment requirement */",
      "56": "line   56 : template <typename Type, unsigned int Size>",
      "57": "line   57 : struct IntType",
      "58": "line   58 : {",
      "59": "line   59 :   inline void set (Type i) { v.set (i); }",
      "60": "line   60 :   inline operator Type(void) const { return v; }",
      "61": "line   61 :   inline bool operator == (const IntType<Type,Size> &o) const { return (Type) v == (Type) o.v; }",
      "62": "line   62 :   inline bool operator != (const IntType<Type,Size> &o) const { return !(*this == o); }",
      "63": "line   63 :   static inline int cmp (const IntType<Type,Size> *a, const IntType<Type,Size> *b) { return b->cmp (*a); }",
      "64": "line   64 :   template <typename Type2>",
      "65": "line   65 :   inline int cmp (Type2 a) const",
      "66": "line   66 :   {",
      "67": "line   67 :     Type b = v;",
      "68": "line   68 :     if (sizeof (Type) < sizeof (int) && sizeof (Type2) < sizeof (int))",
      "69": "line   69 :       return (int) a - (int) b;",
      "70": "line   70 :     else",
      "71": "line   71 :       return a < b ? -1 : a == b ? 0 : +1;",
      "72": "line   72 :   }",
      "73": "line   73 :   inline bool sanitize (hb_sanitize_context_t *c) const",
      "74": "line   74 :   {",
      "75": "line   75 :     TRACE_SANITIZE (this);",
      "76": "line   76 :     return_trace (likely (c->check_struct (this)));",
      "77": "line   77 :   }",
      "78": "line   78 :   protected:",
      "79": "line   79 :   BEInt<Type, Size> v;",
      "80": "line   80 :   public:",
      "81": "line   81 :   DEFINE_SIZE_STATIC (Size);",
      "82": "line   82 : };",
      "83": "line   83 : ",
      "84": "line   84 : typedef IntType<uint8_t,  1> HBUINT8;\t/* 8-bit unsigned integer. */",
      "85": "line   85 : typedef IntType<int8_t,   1> HBINT8;\t/* 8-bit signed integer. */",
      "86": "line   86 : typedef IntType<uint16_t, 2> HBUINT16;\t/* 16-bit unsigned integer. */",
      "87": "line   87 : typedef IntType<int16_t,  2> HBINT16;\t/* 16-bit signed integer. */",
      "88": "line   88 : typedef IntType<uint32_t, 4> HBUINT32;\t/* 32-bit unsigned integer. */",
      "89": "line   89 : typedef IntType<int32_t,  4> HBINT32;\t/* 32-bit signed integer. */",
      "90": "line   90 : typedef IntType<uint32_t, 3> HBUINT24;\t/* 24-bit unsigned integer. */",
      "91": "line   91 : ",
      "92": "line   92 : /* 16-bit signed integer (HBINT16) that describes a quantity in FUnits. */",
      "93": "line   93 : typedef HBINT16 FWORD;",
      "94": "line   94 : ",
      "95": "line   95 : /* 16-bit unsigned integer (HBUINT16) that describes a quantity in FUnits. */",
      "96": "line   96 : typedef HBUINT16 UFWORD;",
      "97": "line   97 : ",
      "98": "line   98 : /* 16-bit signed fixed number with the low 14 bits of fraction (2.14). */",
      "99": "line   99 : struct F2DOT14 : HBINT16",
      "100": "line  100 : {",
      "741": "line  741 : <End of File>"
    },
    "/src/harfbuzz/src/hb-buffer.cc": {
      "1504": "line 1504 :  **/",
      "1505": "line 1505 : void",
      "1506": "line 1506 : hb_buffer_guess_segment_properties (hb_buffer_t *buffer)",
      "1507": "line 1507 : {",
      "1508": "line 1508 :   buffer->guess_segment_properties ();",
      "1509": "line 1509 : }",
      "1510": "line 1510 : ",
      "1511": "line 1511 : template <typename utf_t>",
      "1512": "line 1512 : static inline void",
      "1513": "line 1513 : hb_buffer_add_utf (hb_buffer_t  *buffer,",
      "1514": "line 1514 : \t\t   const typename utf_t::codepoint_t *text,",
      "1515": "line 1515 : \t\t   int           text_length,",
      "1516": "line 1516 : \t\t   unsigned int  item_offset,",
      "1517": "line 1517 : \t\t   int           item_length)",
      "1518": "line 1518 : {",
      "1519": "line 1519 :   typedef typename utf_t::codepoint_t T;",
      "1520": "line 1520 :   const hb_codepoint_t replacement = buffer->replacement;",
      "1521": "line 1521 : ",
      "1522": "line 1522 :   assert (buffer->content_type == HB_BUFFER_CONTENT_TYPE_UNICODE ||",
      "1523": "line 1523 : \t  (!buffer->len && buffer->content_type == HB_BUFFER_CONTENT_TYPE_INVALID));",
      "1524": "line 1524 : ",
      "1525": "line 1525 :   if (unlikely (hb_object_is_inert (buffer)))",
      "1526": "line 1526 :     return;",
      "1527": "line 1527 : ",
      "1528": "line 1528 :   if (text_length == -1)",
      "1529": "line 1529 :     text_length = utf_t::strlen (text);",
      "1530": "line 1530 : ",
      "1531": "line 1531 :   if (item_length == -1)",
      "1532": "line 1532 :     item_length = text_length - item_offset;",
      "1533": "line 1533 : ",
      "1534": "line 1534 :   buffer->ensure (buffer->len + item_length * sizeof (T) / 4);",
      "1535": "line 1535 : ",
      "1536": "line 1536 :   /* If buffer is empty and pre-context provided, install it.",
      "1537": "line 1537 :    * This check is written this way, to make sure people can",
      "1538": "line 1538 :    * provide pre-context in one add_utf() call, then provide",
      "1539": "line 1539 :    * text in a follow-up call.  See:",
      "1540": "line 1540 :    *",
      "1541": "line 1541 :    * https://bugzilla.mozilla.org/show_bug.cgi?id=801410#c13",
      "1542": "line 1542 :    */",
      "1543": "line 1543 :   if (!buffer->len && item_offset > 0)",
      "1544": "line 1544 :   {",
      "1545": "line 1545 :     /* Add pre-context */",
      "1546": "line 1546 :     buffer->clear_context (0);",
      "1547": "line 1547 :     const T *prev = text + item_offset;",
      "1548": "line 1548 :     const T *start = text;",
      "1549": "line 1549 :     while (start < prev && buffer->context_len[0] < buffer->CONTEXT_LENGTH)",
      "1550": "line 1550 :     {",
      "1551": "line 1551 :       hb_codepoint_t u;",
      "1552": "line 1552 :       prev = utf_t::prev (prev, start, &u, replacement);",
      "1553": "line 1553 :       buffer->context[0][buffer->context_len[0]++] = u;",
      "1554": "line 1554 :     }",
      "1555": "line 1555 :   }",
      "1556": "line 1556 : ",
      "1557": "line 1557 :   const T *next = text + item_offset;",
      "1558": "line 1558 :   const T *end = next + item_length;",
      "1559": "line 1559 :   while (next < end)",
      "1560": "line 1560 :   {",
      "1561": "line 1561 :     hb_codepoint_t u;",
      "1562": "line 1562 :     const T *old_next = next;",
      "1563": "line 1563 :     next = utf_t::next (next, end, &u, replacement);",
      "2017": "line 2017 : <End of File>",
      "107": "line  107 : ",
      "108": "line  108 : ",
      "109": "line  109 : /* Internal API */",
      "110": "line  110 : ",
      "111": "line  111 : bool",
      "112": "line  112 : hb_buffer_t::enlarge (unsigned int size)",
      "113": "line  113 : {",
      "114": "line  114 :   if (unlikely (!successful))",
      "115": "line  115 :     return false;",
      "116": "line  116 :   if (unlikely (size > max_len))",
      "117": "line  117 :   {",
      "118": "line  118 :     successful = false;",
      "119": "line  119 :     return false;",
      "120": "line  120 :   }",
      "121": "line  121 : ",
      "122": "line  122 :   unsigned int new_allocated = allocated;",
      "123": "line  123 :   hb_glyph_position_t *new_pos = nullptr;",
      "124": "line  124 :   hb_glyph_info_t *new_info = nullptr;",
      "125": "line  125 :   bool separate_out = out_info != info;",
      "126": "line  126 : ",
      "127": "line  127 :   if (unlikely (hb_unsigned_mul_overflows (size, sizeof (info[0]))))",
      "128": "line  128 :     goto done;",
      "129": "line  129 : ",
      "130": "line  130 :   while (size >= new_allocated)",
      "131": "line  131 :     new_allocated += (new_allocated >> 1) + 32;",
      "132": "line  132 : ",
      "133": "line  133 :   static_assert ((sizeof (info[0]) == sizeof (pos[0])), \"\");",
      "134": "line  134 :   if (unlikely (hb_unsigned_mul_overflows (new_allocated, sizeof (info[0]))))",
      "135": "line  135 :     goto done;",
      "136": "line  136 : ",
      "137": "line  137 :   new_pos = (hb_glyph_position_t *) realloc (pos, new_allocated * sizeof (pos[0]));",
      "138": "line  138 :   new_info = (hb_glyph_info_t *) realloc (info, new_allocated * sizeof (info[0]));",
      "139": "line  139 : ",
      "140": "line  140 : done:",
      "141": "line  141 :   if (unlikely (!new_pos || !new_info))",
      "142": "line  142 :     successful = false;",
      "143": "line  143 : ",
      "144": "line  144 :   if (likely (new_pos))",
      "145": "line  145 :     pos = new_pos;",
      "146": "line  146 : ",
      "147": "line  147 :   if (likely (new_info))",
      "148": "line  148 :     info = new_info;",
      "149": "line  149 : ",
      "150": "line  150 :   out_info = separate_out ? (hb_glyph_info_t *) pos : info;",
      "151": "line  151 :   if (likely (successful))",
      "152": "line  152 :     allocated = new_allocated;",
      "153": "line  153 : ",
      "154": "line  154 :   return likely (successful);",
      "155": "line  155 : }",
      "156": "line  156 : ",
      "157": "line  157 : bool",
      "158": "line  158 : hb_buffer_t::make_room_for (unsigned int num_in,",
      "159": "line  159 : \t\t\t    unsigned int num_out)",
      "160": "line  160 : {",
      "161": "line  161 :   if (unlikely (!ensure (out_len + num_out))) return false;",
      "162": "line  162 : ",
      "163": "line  163 :   if (out_info == info &&",
      "164": "line  164 :       out_len + num_out > idx + num_in)",
      "165": "line  165 :   {",
      "166": "line  166 :     assert (have_output);"
    },
    "/src/harfbuzz/src/./hb-buffer.hh": {
      "251": "line  251 :   }",
      "252": "line  252 :   HB_INTERNAL void set_masks (hb_mask_t value, hb_mask_t mask,",
      "253": "line  253 : \t\t\t      unsigned int cluster_start, unsigned int cluster_end);",
      "254": "line  254 : ",
      "255": "line  255 :   inline void merge_clusters (unsigned int start, unsigned int end)",
      "256": "line  256 :   {",
      "257": "line  257 :     if (end - start < 2)",
      "258": "line  258 :       return;",
      "259": "line  259 :     merge_clusters_impl (start, end);",
      "260": "line  260 :   }",
      "261": "line  261 :   HB_INTERNAL void merge_clusters_impl (unsigned int start, unsigned int end);",
      "262": "line  262 :   HB_INTERNAL void merge_out_clusters (unsigned int start, unsigned int end);",
      "263": "line  263 :   /* Merge clusters for deleting current glyph, and skip it. */",
      "264": "line  264 :   HB_INTERNAL void delete_glyph (void);",
      "265": "line  265 : ",
      "266": "line  266 :   inline void unsafe_to_break (unsigned int start,",
      "267": "line  267 : \t\t\t       unsigned int end)",
      "268": "line  268 :   {",
      "269": "line  269 :     if (end - start < 2)",
      "270": "line  270 :       return;",
      "271": "line  271 :     unsafe_to_break_impl (start, end);",
      "272": "line  272 :   }",
      "273": "line  273 :   HB_INTERNAL void unsafe_to_break_impl (unsigned int start, unsigned int end);",
      "274": "line  274 :   HB_INTERNAL void unsafe_to_break_from_outbuffer (unsigned int start, unsigned int end);",
      "275": "line  275 : ",
      "276": "line  276 : ",
      "277": "line  277 :   /* Internal methods */",
      "278": "line  278 :   HB_INTERNAL bool enlarge (unsigned int size);",
      "279": "line  279 : ",
      "280": "line  280 :   inline bool ensure (unsigned int size)",
      "281": "line  281 :   { return likely (!size || size < allocated) ? true : enlarge (size); }",
      "282": "line  282 : ",
      "283": "line  283 :   inline bool ensure_inplace (unsigned int size)",
      "284": "line  284 :   { return likely (!size || size < allocated); }",
      "285": "line  285 : ",
      "286": "line  286 :   HB_INTERNAL bool make_room_for (unsigned int num_in, unsigned int num_out);",
      "287": "line  287 :   HB_INTERNAL bool shift_forward (unsigned int count);",
      "288": "line  288 : ",
      "289": "line  289 :   typedef long scratch_buffer_t;",
      "290": "line  290 :   HB_INTERNAL scratch_buffer_t *get_scratch_buffer (unsigned int *size);",
      "291": "line  291 : ",
      "292": "line  292 :   inline void clear_context (unsigned int side) { context_len[side] = 0; }",
      "293": "line  293 : ",
      "294": "line  294 :   HB_INTERNAL void sort (unsigned int start, unsigned int end, int(*compar)(const hb_glyph_info_t *, const hb_glyph_info_t *));",
      "295": "line  295 : ",
      "296": "line  296 :   inline bool messaging (void) { return unlikely (message_func); }",
      "297": "line  297 :   inline bool message (hb_font_t *font, const char *fmt, ...) HB_PRINTF_FUNC(3, 4)",
      "298": "line  298 :   {",
      "299": "line  299 :     if (!messaging ())",
      "300": "line  300 :       return true;",
      "301": "line  301 :     va_list ap;",
      "302": "line  302 :     va_start (ap, fmt);",
      "303": "line  303 :     bool ret = message_impl (font, fmt, ap);",
      "304": "line  304 :     va_end (ap);",
      "305": "line  305 :     return ret;",
      "306": "line  306 :   }",
      "307": "line  307 :   HB_INTERNAL bool message_impl (hb_font_t *font, const char *fmt, va_list ap) HB_PRINTF_FUNC(3, 0);",
      "308": "line  308 : ",
      "309": "line  309 :   static inline void",
      "310": "line  310 :   set_cluster (hb_glyph_info_t &inf, unsigned int cluster, unsigned int mask = 0)",
      "391": "line  391 : <End of File>"
    },
    "/src/harfbuzz/src/./hb-open-file.hh": {
      "28": "line   28 : ",
      "29": "line   29 : #ifndef HB_OPEN_FILE_HH",
      "30": "line   30 : #define HB_OPEN_FILE_HH",
      "31": "line   31 : ",
      "32": "line   32 : #include \"hb-open-type.hh\"",
      "33": "line   33 : #include \"hb-ot-head-table.hh\"",
      "34": "line   34 : ",
      "35": "line   35 : ",
      "36": "line   36 : namespace OT {",
      "37": "line   37 : ",
      "38": "line   38 : ",
      "39": "line   39 : /*",
      "40": "line   40 :  *",
      "41": "line   41 :  * The OpenType Font File",
      "42": "line   42 :  *",
      "43": "line   43 :  */",
      "44": "line   44 : ",
      "45": "line   45 : ",
      "46": "line   46 : /*",
      "47": "line   47 :  * Organization of an OpenType Font",
      "48": "line   48 :  */",
      "49": "line   49 : ",
      "50": "line   50 : struct OpenTypeFontFile;",
      "51": "line   51 : struct OffsetTable;",
      "52": "line   52 : struct TTCHeader;",
      "53": "line   53 : ",
      "54": "line   54 : ",
      "55": "line   55 : typedef struct TableRecord",
      "56": "line   56 : {",
      "57": "line   57 :   int cmp (Tag t) const",
      "58": "line   58 :   { return -t.cmp (tag); }",
      "59": "line   59 : ",
      "60": "line   60 :   static int cmp (const void *pa, const void *pb)",
      "61": "line   61 :   {",
      "62": "line   62 :     const TableRecord *a = (const TableRecord *) pa;",
      "63": "line   63 :     const TableRecord *b = (const TableRecord *) pb;",
      "64": "line   64 :     return b->cmp (a->tag);",
      "65": "line   65 :   }",
      "66": "line   66 : ",
      "67": "line   67 :   inline bool sanitize (hb_sanitize_context_t *c) const",
      "68": "line   68 :   {",
      "69": "line   69 :     TRACE_SANITIZE (this);",
      "70": "line   70 :     return_trace (c->check_struct (this));",
      "71": "line   71 :   }",
      "72": "line   72 : ",
      "73": "line   73 :   Tag\t\ttag;\t\t/* 4-byte identifier. */",
      "74": "line   74 :   CheckSum\tcheckSum;\t/* CheckSum for this table. */",
      "75": "line   75 :   Offset32\toffset;\t\t/* Offset from beginning of TrueType font",
      "76": "line   76 : \t\t\t\t * file. */",
      "77": "line   77 :   HBUINT32\tlength;\t\t/* Length of this table. */",
      "78": "line   78 :   public:",
      "79": "line   79 :   DEFINE_SIZE_STATIC (16);",
      "80": "line   80 : } OpenTypeTable;",
      "81": "line   81 : ",
      "82": "line   82 : typedef struct OffsetTable",
      "83": "line   83 : {",
      "84": "line   84 :   friend struct OpenTypeFontFile;",
      "85": "line   85 : ",
      "86": "line   86 :   inline unsigned int get_table_count (void) const",
      "87": "line   87 :   { return tables.len; }",
      "543": "line  543 : <End of File>"
    }
  },
  "note": [
    "Reason for requesting line 18 of /src/harfbuzz/./test/fuzzing/hb-shape-fuzzer.cc: To understand how data is being added to the buffer in the fuzzer.",
    "The crash is a use-of-uninitialized-value during a comparison, originating from uninitialized bytes copied into `text32` in the fuzzer's second code block. This data is then passed to `hb_buffer_add_utf32`, causing the issue when `hb_shape` processes it.",
    "Reason for requesting line 71 of /src/harfbuzz/src/./hb-open-type.hh: To understand the definition of OT::IntType and its comparison operator, which is the site of the uninitialized value use.",
    "Reason for requesting line 1534 of /src/harfbuzz/src/hb-buffer.cc: To understand how the buffer's glyph information is handled and potentially initialized after being resized or cleared. The crash originates from `hb_buffer_t::enlarge` which is called during `hb_buffer_add_utf8`.",
    "Reason for requesting line 281 of /src/harfbuzz/src/./hb-buffer.hh: To check how hb_buffer_t::clear_context and ensure are implemented to identify where the uninitialized memory might be introduced during buffer operations, particularly for the context.",
    "Reason for requesting line 58 of /src/harfbuzz/src/./hb-open-file.hh: To understand how the Tag type is defined and how it might interact with the comparison in IntType.",
    "The issue stems from `hb_buffer_t::enlarge` allocating uninitialized memory. Although this happens during `hb_buffer_add_utf8`, the crash occurs later when this uninitialized data, potentially treated as font tables, is accessed and compared within `OT::IntType::cmp` during font processing.",
    "Reason for requesting line 137 of /src/harfbuzz/src/hb-buffer.cc: To examine the implementation of hb_buffer_t::enlarge and determine where the uninitialized memory is allocated.",
    "The issue is that `realloc` in `hb_buffer_t::enlarge` allocates uninitialized memory for `info` and `pos`. When the buffer is later used, specifically when it's interpreted as font tables, the uninitialized `hb_glyph_info_t` or `hb_glyph_position_t` data is accessed in `OT::IntType::cmp`, leading to a use-of-uninitialized-value crash.",
    "The `realloc` calls in `hb_buffer_t::enlarge` allocate uninitialized memory. This uninitialized data, likely from `hb_glyph_info_t` or `hb_glyph_position_t`, is later used in `OT::IntType::cmp` during font table processing, leading to the use-of-uninitialized-value crash. The fix should initialize this memory."
  ],
  "valid_patches": [
    {
      "file": "/src/harfbuzz/src/hb-buffer.cc",
      "diff": [
        {
          "line_number": 149,
          "content": [
            "  if (likely (new_info))",
            "  {",
            "    /* New parts of info and pos are uninitialized; zero them. */",
            "    if (unlikely (new_allocated > allocated)) {",
            "      memset (new_info + allocated, 0, (new_allocated - allocated) * sizeof (new_info[0]));",
            "      memset (new_pos + allocated, 0, (new_allocated - allocated) * sizeof (new_pos[0]));",
            "    }",
            "    info = new_info;",
            "  }"
          ]
        }
      ]
    }
  ],
  "retry_count": 12,
  "history": [
    {
      "reason": "To understand how data is being added to the buffer in the fuzzer.",
      "line": 18,
      "file": "/src/harfbuzz/./test/fuzzing/hb-shape-fuzzer.cc"
    },
    {
      "content": "The crash is a use-of-uninitialized-value during a comparison, originating from uninitialized bytes copied into `text32` in the fuzzer's second code block. This data is then passed to `hb_buffer_add_utf32`, causing the issue when `hb_shape` processes it."
    },
    {
      "reason": "To understand the definition of OT::IntType and its comparison operator, which is the site of the uninitialized value use.",
      "line": 71,
      "file": "/src/harfbuzz/src/./hb-open-type.hh"
    },
    {
      "reason": "To understand how the buffer's glyph information is handled and potentially initialized after being resized or cleared. The crash originates from `hb_buffer_t::enlarge` which is called during `hb_buffer_add_utf8`.",
      "line": 1534,
      "file": "/src/harfbuzz/src/hb-buffer.cc"
    },
    {
      "reason": "To check how hb_buffer_t::clear_context and ensure are implemented to identify where the uninitialized memory might be introduced during buffer operations, particularly for the context.",
      "line": 281,
      "file": "/src/harfbuzz/src/./hb-buffer.hh"
    },
    {
      "reason": "To understand how the Tag type is defined and how it might interact with the comparison in IntType.",
      "line": 58,
      "file": "/src/harfbuzz/src/./hb-open-file.hh"
    },
    {
      "content": "The issue stems from `hb_buffer_t::enlarge` allocating uninitialized memory. Although this happens during `hb_buffer_add_utf8`, the crash occurs later when this uninitialized data, potentially treated as font tables, is accessed and compared within `OT::IntType::cmp` during font processing."
    },
    {
      "reason": "To examine the implementation of hb_buffer_t::enlarge and determine where the uninitialized memory is allocated.",
      "line": 137,
      "file": "/src/harfbuzz/src/hb-buffer.cc"
    },
    {
      "content": "The issue is that `realloc` in `hb_buffer_t::enlarge` allocates uninitialized memory for `info` and `pos`. When the buffer is later used, specifically when it's interpreted as font tables, the uninitialized `hb_glyph_info_t` or `hb_glyph_position_t` data is accessed in `OT::IntType::cmp`, leading to a use-of-uninitialized-value crash."
    },
    {
      "content": "The `realloc` calls in `hb_buffer_t::enlarge` allocate uninitialized memory. This uninitialized data, likely from `hb_glyph_info_t` or `hb_glyph_position_t`, is later used in `OT::IntType::cmp` during font table processing, leading to the use-of-uninitialized-value crash. The fix should initialize this memory."
    },
    {
      "reason": "The crash is a use-of-uninitialized-value originating from memory allocated by `realloc` in `hb_buffer_t::enlarge`. `realloc` does not guarantee initialization of newly extended memory. The fix is to zero-initialize the newly allocated portions of `hb_glyph_info_t` and `hb_glyph_position_t` buffers after `realloc` in `hb_buffer_t::enlarge` to prevent uninitialized data from being used later in comparisons.",
      "patches": [
        {
          "file": "/src/harfbuzz/src/hb-buffer.cc",
          "diff": [
            {
              "line_number": 149,
              "content": [
                "  if (likely (new_info))",
                "  {",
                "    if (info)",
                "      memset (new_info + allocated, 0, (new_allocated - allocated) * sizeof (new_info[0]));",
                "    info = new_info;",
                "  }",
                "",
                "  out_info = separate_out ? (hb_glyph_info_t *) pos : info;"
              ]
            },
            {
              "line_number": 144,
              "content": [
                "  if (likely (new_pos))",
                "  {",
                "    if (pos)",
                "      memset (new_pos + allocated, 0, (new_allocated - allocated) * sizeof (new_pos[0]));",
                "    pos = new_pos;",
                "  }"
              ]
            },
            {
              "line_number": 152,
              "content": [
                "    allocated = new_allocated;",
                "  }",
                ""
              ]
            }
          ]
        }
      ]
    },
    {
      "reason": "The `realloc` calls in `hb_buffer_t::enlarge` allocate uninitialized memory for `pos` and `info`. This uninitialized data is later accessed, leading to a use-of-uninitialized-value crash during font table processing. The fix is to zero-initialize the newly allocated portions of the `pos` and `info` arrays to prevent reading garbage values.",
      "patches": [
        {
          "file": "/src/harfbuzz/src/hb-buffer.cc",
          "diff": [
            {
              "line_number": 149,
              "content": [
                "  if (likely (new_info))",
                "  {",
                "    /* New parts of info and pos are uninitialized; zero them. */",
                "    if (unlikely (new_allocated > allocated)) {",
                "      memset (new_info + allocated, 0, (new_allocated - allocated) * sizeof (new_info[0]));",
                "      memset (new_pos + allocated, 0, (new_allocated - allocated) * sizeof (new_pos[0]));",
                "    }",
                "    info = new_info;",
                "  }"
              ]
            }
          ]
        }
      ]
    }
  ]
}